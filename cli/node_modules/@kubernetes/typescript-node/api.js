"use strict";
exports.__esModule = true;
/**
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.6.6
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var request = require("request");
var Promise = require("bluebird");
var defaultBasePath = 'https://localhost';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
/**
* Deployment enables declarative updates for Pods and ReplicaSets.
*/
var AppsV1beta1Deployment = (function () {
    function AppsV1beta1Deployment() {
    }
    return AppsV1beta1Deployment;
}());
exports.AppsV1beta1Deployment = AppsV1beta1Deployment;
/**
* DeploymentCondition describes the state of a deployment at a certain point.
*/
var AppsV1beta1DeploymentCondition = (function () {
    function AppsV1beta1DeploymentCondition() {
    }
    return AppsV1beta1DeploymentCondition;
}());
exports.AppsV1beta1DeploymentCondition = AppsV1beta1DeploymentCondition;
/**
* DeploymentList is a list of Deployments.
*/
var AppsV1beta1DeploymentList = (function () {
    function AppsV1beta1DeploymentList() {
    }
    return AppsV1beta1DeploymentList;
}());
exports.AppsV1beta1DeploymentList = AppsV1beta1DeploymentList;
/**
* DeploymentRollback stores the information required to rollback a deployment.
*/
var AppsV1beta1DeploymentRollback = (function () {
    function AppsV1beta1DeploymentRollback() {
    }
    return AppsV1beta1DeploymentRollback;
}());
exports.AppsV1beta1DeploymentRollback = AppsV1beta1DeploymentRollback;
/**
* DeploymentSpec is the specification of the desired behavior of the Deployment.
*/
var AppsV1beta1DeploymentSpec = (function () {
    function AppsV1beta1DeploymentSpec() {
    }
    return AppsV1beta1DeploymentSpec;
}());
exports.AppsV1beta1DeploymentSpec = AppsV1beta1DeploymentSpec;
/**
* DeploymentStatus is the most recently observed status of the Deployment.
*/
var AppsV1beta1DeploymentStatus = (function () {
    function AppsV1beta1DeploymentStatus() {
    }
    return AppsV1beta1DeploymentStatus;
}());
exports.AppsV1beta1DeploymentStatus = AppsV1beta1DeploymentStatus;
/**
* DeploymentStrategy describes how to replace existing pods with new ones.
*/
var AppsV1beta1DeploymentStrategy = (function () {
    function AppsV1beta1DeploymentStrategy() {
    }
    return AppsV1beta1DeploymentStrategy;
}());
exports.AppsV1beta1DeploymentStrategy = AppsV1beta1DeploymentStrategy;
var AppsV1beta1RollbackConfig = (function () {
    function AppsV1beta1RollbackConfig() {
    }
    return AppsV1beta1RollbackConfig;
}());
exports.AppsV1beta1RollbackConfig = AppsV1beta1RollbackConfig;
/**
* Spec to control the desired behavior of rolling update.
*/
var AppsV1beta1RollingUpdateDeployment = (function () {
    function AppsV1beta1RollingUpdateDeployment() {
    }
    return AppsV1beta1RollingUpdateDeployment;
}());
exports.AppsV1beta1RollingUpdateDeployment = AppsV1beta1RollingUpdateDeployment;
/**
* Scale represents a scaling request for a resource.
*/
var AppsV1beta1Scale = (function () {
    function AppsV1beta1Scale() {
    }
    return AppsV1beta1Scale;
}());
exports.AppsV1beta1Scale = AppsV1beta1Scale;
/**
* ScaleSpec describes the attributes of a scale subresource
*/
var AppsV1beta1ScaleSpec = (function () {
    function AppsV1beta1ScaleSpec() {
    }
    return AppsV1beta1ScaleSpec;
}());
exports.AppsV1beta1ScaleSpec = AppsV1beta1ScaleSpec;
/**
* ScaleStatus represents the current status of a scale subresource.
*/
var AppsV1beta1ScaleStatus = (function () {
    function AppsV1beta1ScaleStatus() {
    }
    return AppsV1beta1ScaleStatus;
}());
exports.AppsV1beta1ScaleStatus = AppsV1beta1ScaleStatus;
/**
* Deployment enables declarative updates for Pods and ReplicaSets.
*/
var ExtensionsV1beta1Deployment = (function () {
    function ExtensionsV1beta1Deployment() {
    }
    return ExtensionsV1beta1Deployment;
}());
exports.ExtensionsV1beta1Deployment = ExtensionsV1beta1Deployment;
/**
* DeploymentCondition describes the state of a deployment at a certain point.
*/
var ExtensionsV1beta1DeploymentCondition = (function () {
    function ExtensionsV1beta1DeploymentCondition() {
    }
    return ExtensionsV1beta1DeploymentCondition;
}());
exports.ExtensionsV1beta1DeploymentCondition = ExtensionsV1beta1DeploymentCondition;
/**
* DeploymentList is a list of Deployments.
*/
var ExtensionsV1beta1DeploymentList = (function () {
    function ExtensionsV1beta1DeploymentList() {
    }
    return ExtensionsV1beta1DeploymentList;
}());
exports.ExtensionsV1beta1DeploymentList = ExtensionsV1beta1DeploymentList;
/**
* DeploymentRollback stores the information required to rollback a deployment.
*/
var ExtensionsV1beta1DeploymentRollback = (function () {
    function ExtensionsV1beta1DeploymentRollback() {
    }
    return ExtensionsV1beta1DeploymentRollback;
}());
exports.ExtensionsV1beta1DeploymentRollback = ExtensionsV1beta1DeploymentRollback;
/**
* DeploymentSpec is the specification of the desired behavior of the Deployment.
*/
var ExtensionsV1beta1DeploymentSpec = (function () {
    function ExtensionsV1beta1DeploymentSpec() {
    }
    return ExtensionsV1beta1DeploymentSpec;
}());
exports.ExtensionsV1beta1DeploymentSpec = ExtensionsV1beta1DeploymentSpec;
/**
* DeploymentStatus is the most recently observed status of the Deployment.
*/
var ExtensionsV1beta1DeploymentStatus = (function () {
    function ExtensionsV1beta1DeploymentStatus() {
    }
    return ExtensionsV1beta1DeploymentStatus;
}());
exports.ExtensionsV1beta1DeploymentStatus = ExtensionsV1beta1DeploymentStatus;
/**
* DeploymentStrategy describes how to replace existing pods with new ones.
*/
var ExtensionsV1beta1DeploymentStrategy = (function () {
    function ExtensionsV1beta1DeploymentStrategy() {
    }
    return ExtensionsV1beta1DeploymentStrategy;
}());
exports.ExtensionsV1beta1DeploymentStrategy = ExtensionsV1beta1DeploymentStrategy;
var ExtensionsV1beta1RollbackConfig = (function () {
    function ExtensionsV1beta1RollbackConfig() {
    }
    return ExtensionsV1beta1RollbackConfig;
}());
exports.ExtensionsV1beta1RollbackConfig = ExtensionsV1beta1RollbackConfig;
/**
* Spec to control the desired behavior of rolling update.
*/
var ExtensionsV1beta1RollingUpdateDeployment = (function () {
    function ExtensionsV1beta1RollingUpdateDeployment() {
    }
    return ExtensionsV1beta1RollingUpdateDeployment;
}());
exports.ExtensionsV1beta1RollingUpdateDeployment = ExtensionsV1beta1RollingUpdateDeployment;
/**
* represents a scaling request for a resource.
*/
var ExtensionsV1beta1Scale = (function () {
    function ExtensionsV1beta1Scale() {
    }
    return ExtensionsV1beta1Scale;
}());
exports.ExtensionsV1beta1Scale = ExtensionsV1beta1Scale;
/**
* describes the attributes of a scale subresource
*/
var ExtensionsV1beta1ScaleSpec = (function () {
    function ExtensionsV1beta1ScaleSpec() {
    }
    return ExtensionsV1beta1ScaleSpec;
}());
exports.ExtensionsV1beta1ScaleSpec = ExtensionsV1beta1ScaleSpec;
/**
* represents the current status of a scale subresource.
*/
var ExtensionsV1beta1ScaleStatus = (function () {
    function ExtensionsV1beta1ScaleStatus() {
    }
    return ExtensionsV1beta1ScaleStatus;
}());
exports.ExtensionsV1beta1ScaleStatus = ExtensionsV1beta1ScaleStatus;
/**
* RawExtension is used to hold extensions in external versions.  To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.  // Internal package: type MyAPIObject struct {  runtime.TypeMeta `json:\",inline\"`  MyPlugin runtime.Object `json:\"myPlugin\"` } type PluginA struct {  AOption string `json:\"aOption\"` }  // External package: type MyAPIObject struct {  runtime.TypeMeta `json:\",inline\"`  MyPlugin runtime.RawExtension `json:\"myPlugin\"` } type PluginA struct {  AOption string `json:\"aOption\"` }  // On the wire, the JSON will look something like this: {  \"kind\":\"MyAPIObject\",  \"apiVersion\":\"v1\",  \"myPlugin\": {   \"kind\":\"PluginA\",   \"aOption\":\"foo\",  }, }  So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
*/
var RuntimeRawExtension = (function () {
    function RuntimeRawExtension() {
    }
    return RuntimeRawExtension;
}());
exports.RuntimeRawExtension = RuntimeRawExtension;
/**
* APIGroup contains the name, the supported versions, and the preferred version of a group.
*/
var V1APIGroup = (function () {
    function V1APIGroup() {
    }
    return V1APIGroup;
}());
exports.V1APIGroup = V1APIGroup;
/**
* APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.
*/
var V1APIGroupList = (function () {
    function V1APIGroupList() {
    }
    return V1APIGroupList;
}());
exports.V1APIGroupList = V1APIGroupList;
/**
* APIResource specifies the name of a resource and whether it is namespaced.
*/
var V1APIResource = (function () {
    function V1APIResource() {
    }
    return V1APIResource;
}());
exports.V1APIResource = V1APIResource;
/**
* APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced.
*/
var V1APIResourceList = (function () {
    function V1APIResourceList() {
    }
    return V1APIResourceList;
}());
exports.V1APIResourceList = V1APIResourceList;
/**
* APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API.
*/
var V1APIVersions = (function () {
    function V1APIVersions() {
    }
    return V1APIVersions;
}());
exports.V1APIVersions = V1APIVersions;
/**
* Represents a Persistent Disk resource in AWS.  An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
*/
var V1AWSElasticBlockStoreVolumeSource = (function () {
    function V1AWSElasticBlockStoreVolumeSource() {
    }
    return V1AWSElasticBlockStoreVolumeSource;
}());
exports.V1AWSElasticBlockStoreVolumeSource = V1AWSElasticBlockStoreVolumeSource;
/**
* Affinity is a group of affinity scheduling rules.
*/
var V1Affinity = (function () {
    function V1Affinity() {
    }
    return V1Affinity;
}());
exports.V1Affinity = V1Affinity;
/**
* AttachedVolume describes a volume attached to a node
*/
var V1AttachedVolume = (function () {
    function V1AttachedVolume() {
    }
    return V1AttachedVolume;
}());
exports.V1AttachedVolume = V1AttachedVolume;
/**
* AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
*/
var V1AzureDiskVolumeSource = (function () {
    function V1AzureDiskVolumeSource() {
    }
    return V1AzureDiskVolumeSource;
}());
exports.V1AzureDiskVolumeSource = V1AzureDiskVolumeSource;
/**
* AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
*/
var V1AzureFileVolumeSource = (function () {
    function V1AzureFileVolumeSource() {
    }
    return V1AzureFileVolumeSource;
}());
exports.V1AzureFileVolumeSource = V1AzureFileVolumeSource;
/**
* Binding ties one object to another. For example, a pod is bound to a node by a scheduler.
*/
var V1Binding = (function () {
    function V1Binding() {
    }
    return V1Binding;
}());
exports.V1Binding = V1Binding;
/**
* Adds and removes POSIX capabilities from running containers.
*/
var V1Capabilities = (function () {
    function V1Capabilities() {
    }
    return V1Capabilities;
}());
exports.V1Capabilities = V1Capabilities;
/**
* Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
*/
var V1CephFSVolumeSource = (function () {
    function V1CephFSVolumeSource() {
    }
    return V1CephFSVolumeSource;
}());
exports.V1CephFSVolumeSource = V1CephFSVolumeSource;
/**
* Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
*/
var V1CinderVolumeSource = (function () {
    function V1CinderVolumeSource() {
    }
    return V1CinderVolumeSource;
}());
exports.V1CinderVolumeSource = V1CinderVolumeSource;
/**
* Information about the condition of a component.
*/
var V1ComponentCondition = (function () {
    function V1ComponentCondition() {
    }
    return V1ComponentCondition;
}());
exports.V1ComponentCondition = V1ComponentCondition;
/**
* ComponentStatus (and ComponentStatusList) holds the cluster validation info.
*/
var V1ComponentStatus = (function () {
    function V1ComponentStatus() {
    }
    return V1ComponentStatus;
}());
exports.V1ComponentStatus = V1ComponentStatus;
/**
* Status of all the conditions for the component as a list of ComponentStatus objects.
*/
var V1ComponentStatusList = (function () {
    function V1ComponentStatusList() {
    }
    return V1ComponentStatusList;
}());
exports.V1ComponentStatusList = V1ComponentStatusList;
/**
* ConfigMap holds configuration data for pods to consume.
*/
var V1ConfigMap = (function () {
    function V1ConfigMap() {
    }
    return V1ConfigMap;
}());
exports.V1ConfigMap = V1ConfigMap;
/**
* ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.  The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
*/
var V1ConfigMapEnvSource = (function () {
    function V1ConfigMapEnvSource() {
    }
    return V1ConfigMapEnvSource;
}());
exports.V1ConfigMapEnvSource = V1ConfigMapEnvSource;
/**
* Selects a key from a ConfigMap.
*/
var V1ConfigMapKeySelector = (function () {
    function V1ConfigMapKeySelector() {
    }
    return V1ConfigMapKeySelector;
}());
exports.V1ConfigMapKeySelector = V1ConfigMapKeySelector;
/**
* ConfigMapList is a resource containing a list of ConfigMap objects.
*/
var V1ConfigMapList = (function () {
    function V1ConfigMapList() {
    }
    return V1ConfigMapList;
}());
exports.V1ConfigMapList = V1ConfigMapList;
/**
* Adapts a ConfigMap into a projected volume.  The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
*/
var V1ConfigMapProjection = (function () {
    function V1ConfigMapProjection() {
    }
    return V1ConfigMapProjection;
}());
exports.V1ConfigMapProjection = V1ConfigMapProjection;
/**
* Adapts a ConfigMap into a volume.  The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
*/
var V1ConfigMapVolumeSource = (function () {
    function V1ConfigMapVolumeSource() {
    }
    return V1ConfigMapVolumeSource;
}());
exports.V1ConfigMapVolumeSource = V1ConfigMapVolumeSource;
/**
* A single application container that you want to run within a pod.
*/
var V1Container = (function () {
    function V1Container() {
    }
    return V1Container;
}());
exports.V1Container = V1Container;
/**
* Describe a container image
*/
var V1ContainerImage = (function () {
    function V1ContainerImage() {
    }
    return V1ContainerImage;
}());
exports.V1ContainerImage = V1ContainerImage;
/**
* ContainerPort represents a network port in a single container.
*/
var V1ContainerPort = (function () {
    function V1ContainerPort() {
    }
    return V1ContainerPort;
}());
exports.V1ContainerPort = V1ContainerPort;
/**
* ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
*/
var V1ContainerState = (function () {
    function V1ContainerState() {
    }
    return V1ContainerState;
}());
exports.V1ContainerState = V1ContainerState;
/**
* ContainerStateRunning is a running state of a container.
*/
var V1ContainerStateRunning = (function () {
    function V1ContainerStateRunning() {
    }
    return V1ContainerStateRunning;
}());
exports.V1ContainerStateRunning = V1ContainerStateRunning;
/**
* ContainerStateTerminated is a terminated state of a container.
*/
var V1ContainerStateTerminated = (function () {
    function V1ContainerStateTerminated() {
    }
    return V1ContainerStateTerminated;
}());
exports.V1ContainerStateTerminated = V1ContainerStateTerminated;
/**
* ContainerStateWaiting is a waiting state of a container.
*/
var V1ContainerStateWaiting = (function () {
    function V1ContainerStateWaiting() {
    }
    return V1ContainerStateWaiting;
}());
exports.V1ContainerStateWaiting = V1ContainerStateWaiting;
/**
* ContainerStatus contains details for the current status of this container.
*/
var V1ContainerStatus = (function () {
    function V1ContainerStatus() {
    }
    return V1ContainerStatus;
}());
exports.V1ContainerStatus = V1ContainerStatus;
/**
* CrossVersionObjectReference contains enough information to let you identify the referred resource.
*/
var V1CrossVersionObjectReference = (function () {
    function V1CrossVersionObjectReference() {
    }
    return V1CrossVersionObjectReference;
}());
exports.V1CrossVersionObjectReference = V1CrossVersionObjectReference;
/**
* DaemonEndpoint contains information about a single Daemon endpoint.
*/
var V1DaemonEndpoint = (function () {
    function V1DaemonEndpoint() {
    }
    return V1DaemonEndpoint;
}());
exports.V1DaemonEndpoint = V1DaemonEndpoint;
/**
* DeleteOptions may be provided when deleting an API object.
*/
var V1DeleteOptions = (function () {
    function V1DeleteOptions() {
    }
    return V1DeleteOptions;
}());
exports.V1DeleteOptions = V1DeleteOptions;
/**
* Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
*/
var V1DownwardAPIProjection = (function () {
    function V1DownwardAPIProjection() {
    }
    return V1DownwardAPIProjection;
}());
exports.V1DownwardAPIProjection = V1DownwardAPIProjection;
/**
* DownwardAPIVolumeFile represents information to create the file containing the pod field
*/
var V1DownwardAPIVolumeFile = (function () {
    function V1DownwardAPIVolumeFile() {
    }
    return V1DownwardAPIVolumeFile;
}());
exports.V1DownwardAPIVolumeFile = V1DownwardAPIVolumeFile;
/**
* DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
*/
var V1DownwardAPIVolumeSource = (function () {
    function V1DownwardAPIVolumeSource() {
    }
    return V1DownwardAPIVolumeSource;
}());
exports.V1DownwardAPIVolumeSource = V1DownwardAPIVolumeSource;
/**
* Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
*/
var V1EmptyDirVolumeSource = (function () {
    function V1EmptyDirVolumeSource() {
    }
    return V1EmptyDirVolumeSource;
}());
exports.V1EmptyDirVolumeSource = V1EmptyDirVolumeSource;
/**
* EndpointAddress is a tuple that describes single IP address.
*/
var V1EndpointAddress = (function () {
    function V1EndpointAddress() {
    }
    return V1EndpointAddress;
}());
exports.V1EndpointAddress = V1EndpointAddress;
/**
* EndpointPort is a tuple that describes a single port.
*/
var V1EndpointPort = (function () {
    function V1EndpointPort() {
    }
    return V1EndpointPort;
}());
exports.V1EndpointPort = V1EndpointPort;
/**
* EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:   {     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],     Ports:     [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]   } The resulting set of endpoints can be viewed as:     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
*/
var V1EndpointSubset = (function () {
    function V1EndpointSubset() {
    }
    return V1EndpointSubset;
}());
exports.V1EndpointSubset = V1EndpointSubset;
/**
* Endpoints is a collection of endpoints that implement the actual service. Example:   Name: \"mysvc\",   Subsets: [     {       Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],       Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]     },     {       Addresses: [{\"ip\": \"10.10.3.3\"}],       Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]     },  ]
*/
var V1Endpoints = (function () {
    function V1Endpoints() {
    }
    return V1Endpoints;
}());
exports.V1Endpoints = V1Endpoints;
/**
* EndpointsList is a list of endpoints.
*/
var V1EndpointsList = (function () {
    function V1EndpointsList() {
    }
    return V1EndpointsList;
}());
exports.V1EndpointsList = V1EndpointsList;
/**
* EnvFromSource represents the source of a set of ConfigMaps
*/
var V1EnvFromSource = (function () {
    function V1EnvFromSource() {
    }
    return V1EnvFromSource;
}());
exports.V1EnvFromSource = V1EnvFromSource;
/**
* EnvVar represents an environment variable present in a Container.
*/
var V1EnvVar = (function () {
    function V1EnvVar() {
    }
    return V1EnvVar;
}());
exports.V1EnvVar = V1EnvVar;
/**
* EnvVarSource represents a source for the value of an EnvVar.
*/
var V1EnvVarSource = (function () {
    function V1EnvVarSource() {
    }
    return V1EnvVarSource;
}());
exports.V1EnvVarSource = V1EnvVarSource;
/**
* Event is a report of an event somewhere in the cluster.
*/
var V1Event = (function () {
    function V1Event() {
    }
    return V1Event;
}());
exports.V1Event = V1Event;
/**
* EventList is a list of events.
*/
var V1EventList = (function () {
    function V1EventList() {
    }
    return V1EventList;
}());
exports.V1EventList = V1EventList;
/**
* EventSource contains information for an event.
*/
var V1EventSource = (function () {
    function V1EventSource() {
    }
    return V1EventSource;
}());
exports.V1EventSource = V1EventSource;
/**
* ExecAction describes a \"run in container\" action.
*/
var V1ExecAction = (function () {
    function V1ExecAction() {
    }
    return V1ExecAction;
}());
exports.V1ExecAction = V1ExecAction;
/**
* Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
*/
var V1FCVolumeSource = (function () {
    function V1FCVolumeSource() {
    }
    return V1FCVolumeSource;
}());
exports.V1FCVolumeSource = V1FCVolumeSource;
/**
* FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
*/
var V1FlexVolumeSource = (function () {
    function V1FlexVolumeSource() {
    }
    return V1FlexVolumeSource;
}());
exports.V1FlexVolumeSource = V1FlexVolumeSource;
/**
* Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
*/
var V1FlockerVolumeSource = (function () {
    function V1FlockerVolumeSource() {
    }
    return V1FlockerVolumeSource;
}());
exports.V1FlockerVolumeSource = V1FlockerVolumeSource;
/**
* Represents a Persistent Disk resource in Google Compute Engine.  A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
*/
var V1GCEPersistentDiskVolumeSource = (function () {
    function V1GCEPersistentDiskVolumeSource() {
    }
    return V1GCEPersistentDiskVolumeSource;
}());
exports.V1GCEPersistentDiskVolumeSource = V1GCEPersistentDiskVolumeSource;
/**
* Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.
*/
var V1GitRepoVolumeSource = (function () {
    function V1GitRepoVolumeSource() {
    }
    return V1GitRepoVolumeSource;
}());
exports.V1GitRepoVolumeSource = V1GitRepoVolumeSource;
/**
* Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
*/
var V1GlusterfsVolumeSource = (function () {
    function V1GlusterfsVolumeSource() {
    }
    return V1GlusterfsVolumeSource;
}());
exports.V1GlusterfsVolumeSource = V1GlusterfsVolumeSource;
/**
* GroupVersion contains the \"group/version\" and \"version\" string of a version. It is made a struct to keep extensibility.
*/
var V1GroupVersionForDiscovery = (function () {
    function V1GroupVersionForDiscovery() {
    }
    return V1GroupVersionForDiscovery;
}());
exports.V1GroupVersionForDiscovery = V1GroupVersionForDiscovery;
/**
* HTTPGetAction describes an action based on HTTP Get requests.
*/
var V1HTTPGetAction = (function () {
    function V1HTTPGetAction() {
    }
    return V1HTTPGetAction;
}());
exports.V1HTTPGetAction = V1HTTPGetAction;
/**
* HTTPHeader describes a custom header to be used in HTTP probes
*/
var V1HTTPHeader = (function () {
    function V1HTTPHeader() {
    }
    return V1HTTPHeader;
}());
exports.V1HTTPHeader = V1HTTPHeader;
/**
* Handler defines a specific action that should be taken
*/
var V1Handler = (function () {
    function V1Handler() {
    }
    return V1Handler;
}());
exports.V1Handler = V1Handler;
/**
* configuration of a horizontal pod autoscaler.
*/
var V1HorizontalPodAutoscaler = (function () {
    function V1HorizontalPodAutoscaler() {
    }
    return V1HorizontalPodAutoscaler;
}());
exports.V1HorizontalPodAutoscaler = V1HorizontalPodAutoscaler;
/**
* list of horizontal pod autoscaler objects.
*/
var V1HorizontalPodAutoscalerList = (function () {
    function V1HorizontalPodAutoscalerList() {
    }
    return V1HorizontalPodAutoscalerList;
}());
exports.V1HorizontalPodAutoscalerList = V1HorizontalPodAutoscalerList;
/**
* specification of a horizontal pod autoscaler.
*/
var V1HorizontalPodAutoscalerSpec = (function () {
    function V1HorizontalPodAutoscalerSpec() {
    }
    return V1HorizontalPodAutoscalerSpec;
}());
exports.V1HorizontalPodAutoscalerSpec = V1HorizontalPodAutoscalerSpec;
/**
* current status of a horizontal pod autoscaler
*/
var V1HorizontalPodAutoscalerStatus = (function () {
    function V1HorizontalPodAutoscalerStatus() {
    }
    return V1HorizontalPodAutoscalerStatus;
}());
exports.V1HorizontalPodAutoscalerStatus = V1HorizontalPodAutoscalerStatus;
/**
* Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
*/
var V1HostPathVolumeSource = (function () {
    function V1HostPathVolumeSource() {
    }
    return V1HostPathVolumeSource;
}());
exports.V1HostPathVolumeSource = V1HostPathVolumeSource;
/**
* Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
*/
var V1ISCSIVolumeSource = (function () {
    function V1ISCSIVolumeSource() {
    }
    return V1ISCSIVolumeSource;
}());
exports.V1ISCSIVolumeSource = V1ISCSIVolumeSource;
/**
* Job represents the configuration of a single job.
*/
var V1Job = (function () {
    function V1Job() {
    }
    return V1Job;
}());
exports.V1Job = V1Job;
/**
* JobCondition describes current state of a job.
*/
var V1JobCondition = (function () {
    function V1JobCondition() {
    }
    return V1JobCondition;
}());
exports.V1JobCondition = V1JobCondition;
/**
* JobList is a collection of jobs.
*/
var V1JobList = (function () {
    function V1JobList() {
    }
    return V1JobList;
}());
exports.V1JobList = V1JobList;
/**
* JobSpec describes how the job execution will look like.
*/
var V1JobSpec = (function () {
    function V1JobSpec() {
    }
    return V1JobSpec;
}());
exports.V1JobSpec = V1JobSpec;
/**
* JobStatus represents the current state of a Job.
*/
var V1JobStatus = (function () {
    function V1JobStatus() {
    }
    return V1JobStatus;
}());
exports.V1JobStatus = V1JobStatus;
/**
* Maps a string key to a path within a volume.
*/
var V1KeyToPath = (function () {
    function V1KeyToPath() {
    }
    return V1KeyToPath;
}());
exports.V1KeyToPath = V1KeyToPath;
/**
* A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
*/
var V1LabelSelector = (function () {
    function V1LabelSelector() {
    }
    return V1LabelSelector;
}());
exports.V1LabelSelector = V1LabelSelector;
/**
* A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
*/
var V1LabelSelectorRequirement = (function () {
    function V1LabelSelectorRequirement() {
    }
    return V1LabelSelectorRequirement;
}());
exports.V1LabelSelectorRequirement = V1LabelSelectorRequirement;
/**
* Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
*/
var V1Lifecycle = (function () {
    function V1Lifecycle() {
    }
    return V1Lifecycle;
}());
exports.V1Lifecycle = V1Lifecycle;
/**
* LimitRange sets resource usage limits for each kind of resource in a Namespace.
*/
var V1LimitRange = (function () {
    function V1LimitRange() {
    }
    return V1LimitRange;
}());
exports.V1LimitRange = V1LimitRange;
/**
* LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
*/
var V1LimitRangeItem = (function () {
    function V1LimitRangeItem() {
    }
    return V1LimitRangeItem;
}());
exports.V1LimitRangeItem = V1LimitRangeItem;
/**
* LimitRangeList is a list of LimitRange items.
*/
var V1LimitRangeList = (function () {
    function V1LimitRangeList() {
    }
    return V1LimitRangeList;
}());
exports.V1LimitRangeList = V1LimitRangeList;
/**
* LimitRangeSpec defines a min/max usage limit for resources that match on kind.
*/
var V1LimitRangeSpec = (function () {
    function V1LimitRangeSpec() {
    }
    return V1LimitRangeSpec;
}());
exports.V1LimitRangeSpec = V1LimitRangeSpec;
/**
* ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
*/
var V1ListMeta = (function () {
    function V1ListMeta() {
    }
    return V1ListMeta;
}());
exports.V1ListMeta = V1ListMeta;
/**
* LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.
*/
var V1LoadBalancerIngress = (function () {
    function V1LoadBalancerIngress() {
    }
    return V1LoadBalancerIngress;
}());
exports.V1LoadBalancerIngress = V1LoadBalancerIngress;
/**
* LoadBalancerStatus represents the status of a load-balancer.
*/
var V1LoadBalancerStatus = (function () {
    function V1LoadBalancerStatus() {
    }
    return V1LoadBalancerStatus;
}());
exports.V1LoadBalancerStatus = V1LoadBalancerStatus;
/**
* LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
*/
var V1LocalObjectReference = (function () {
    function V1LocalObjectReference() {
    }
    return V1LocalObjectReference;
}());
exports.V1LocalObjectReference = V1LocalObjectReference;
/**
* LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.
*/
var V1LocalSubjectAccessReview = (function () {
    function V1LocalSubjectAccessReview() {
    }
    return V1LocalSubjectAccessReview;
}());
exports.V1LocalSubjectAccessReview = V1LocalSubjectAccessReview;
/**
* Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
*/
var V1NFSVolumeSource = (function () {
    function V1NFSVolumeSource() {
    }
    return V1NFSVolumeSource;
}());
exports.V1NFSVolumeSource = V1NFSVolumeSource;
/**
* Namespace provides a scope for Names. Use of multiple namespaces is optional.
*/
var V1Namespace = (function () {
    function V1Namespace() {
    }
    return V1Namespace;
}());
exports.V1Namespace = V1Namespace;
/**
* NamespaceList is a list of Namespaces.
*/
var V1NamespaceList = (function () {
    function V1NamespaceList() {
    }
    return V1NamespaceList;
}());
exports.V1NamespaceList = V1NamespaceList;
/**
* NamespaceSpec describes the attributes on a Namespace.
*/
var V1NamespaceSpec = (function () {
    function V1NamespaceSpec() {
    }
    return V1NamespaceSpec;
}());
exports.V1NamespaceSpec = V1NamespaceSpec;
/**
* NamespaceStatus is information about the current status of a Namespace.
*/
var V1NamespaceStatus = (function () {
    function V1NamespaceStatus() {
    }
    return V1NamespaceStatus;
}());
exports.V1NamespaceStatus = V1NamespaceStatus;
/**
* Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd).
*/
var V1Node = (function () {
    function V1Node() {
    }
    return V1Node;
}());
exports.V1Node = V1Node;
/**
* NodeAddress contains information for the node's address.
*/
var V1NodeAddress = (function () {
    function V1NodeAddress() {
    }
    return V1NodeAddress;
}());
exports.V1NodeAddress = V1NodeAddress;
/**
* Node affinity is a group of node affinity scheduling rules.
*/
var V1NodeAffinity = (function () {
    function V1NodeAffinity() {
    }
    return V1NodeAffinity;
}());
exports.V1NodeAffinity = V1NodeAffinity;
/**
* NodeCondition contains condition information for a node.
*/
var V1NodeCondition = (function () {
    function V1NodeCondition() {
    }
    return V1NodeCondition;
}());
exports.V1NodeCondition = V1NodeCondition;
/**
* NodeDaemonEndpoints lists ports opened by daemons running on the Node.
*/
var V1NodeDaemonEndpoints = (function () {
    function V1NodeDaemonEndpoints() {
    }
    return V1NodeDaemonEndpoints;
}());
exports.V1NodeDaemonEndpoints = V1NodeDaemonEndpoints;
/**
* NodeList is the whole list of all Nodes which have been registered with master.
*/
var V1NodeList = (function () {
    function V1NodeList() {
    }
    return V1NodeList;
}());
exports.V1NodeList = V1NodeList;
/**
* A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
*/
var V1NodeSelector = (function () {
    function V1NodeSelector() {
    }
    return V1NodeSelector;
}());
exports.V1NodeSelector = V1NodeSelector;
/**
* A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
*/
var V1NodeSelectorRequirement = (function () {
    function V1NodeSelectorRequirement() {
    }
    return V1NodeSelectorRequirement;
}());
exports.V1NodeSelectorRequirement = V1NodeSelectorRequirement;
/**
* A null or empty node selector term matches no objects.
*/
var V1NodeSelectorTerm = (function () {
    function V1NodeSelectorTerm() {
    }
    return V1NodeSelectorTerm;
}());
exports.V1NodeSelectorTerm = V1NodeSelectorTerm;
/**
* NodeSpec describes the attributes that a node is created with.
*/
var V1NodeSpec = (function () {
    function V1NodeSpec() {
    }
    return V1NodeSpec;
}());
exports.V1NodeSpec = V1NodeSpec;
/**
* NodeStatus is information about the current status of a node.
*/
var V1NodeStatus = (function () {
    function V1NodeStatus() {
    }
    return V1NodeStatus;
}());
exports.V1NodeStatus = V1NodeStatus;
/**
* NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
*/
var V1NodeSystemInfo = (function () {
    function V1NodeSystemInfo() {
    }
    return V1NodeSystemInfo;
}());
exports.V1NodeSystemInfo = V1NodeSystemInfo;
/**
* NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface
*/
var V1NonResourceAttributes = (function () {
    function V1NonResourceAttributes() {
    }
    return V1NonResourceAttributes;
}());
exports.V1NonResourceAttributes = V1NonResourceAttributes;
/**
* ObjectFieldSelector selects an APIVersioned field of an object.
*/
var V1ObjectFieldSelector = (function () {
    function V1ObjectFieldSelector() {
    }
    return V1ObjectFieldSelector;
}());
exports.V1ObjectFieldSelector = V1ObjectFieldSelector;
/**
* ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
*/
var V1ObjectMeta = (function () {
    function V1ObjectMeta() {
    }
    return V1ObjectMeta;
}());
exports.V1ObjectMeta = V1ObjectMeta;
/**
* ObjectReference contains enough information to let you inspect or modify the referred object.
*/
var V1ObjectReference = (function () {
    function V1ObjectReference() {
    }
    return V1ObjectReference;
}());
exports.V1ObjectReference = V1ObjectReference;
/**
* OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.
*/
var V1OwnerReference = (function () {
    function V1OwnerReference() {
    }
    return V1OwnerReference;
}());
exports.V1OwnerReference = V1OwnerReference;
/**
* PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: http://kubernetes.io/docs/user-guide/persistent-volumes
*/
var V1PersistentVolume = (function () {
    function V1PersistentVolume() {
    }
    return V1PersistentVolume;
}());
exports.V1PersistentVolume = V1PersistentVolume;
/**
* PersistentVolumeClaim is a user's request for and claim to a persistent volume
*/
var V1PersistentVolumeClaim = (function () {
    function V1PersistentVolumeClaim() {
    }
    return V1PersistentVolumeClaim;
}());
exports.V1PersistentVolumeClaim = V1PersistentVolumeClaim;
/**
* PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
*/
var V1PersistentVolumeClaimList = (function () {
    function V1PersistentVolumeClaimList() {
    }
    return V1PersistentVolumeClaimList;
}());
exports.V1PersistentVolumeClaimList = V1PersistentVolumeClaimList;
/**
* PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
*/
var V1PersistentVolumeClaimSpec = (function () {
    function V1PersistentVolumeClaimSpec() {
    }
    return V1PersistentVolumeClaimSpec;
}());
exports.V1PersistentVolumeClaimSpec = V1PersistentVolumeClaimSpec;
/**
* PersistentVolumeClaimStatus is the current status of a persistent volume claim.
*/
var V1PersistentVolumeClaimStatus = (function () {
    function V1PersistentVolumeClaimStatus() {
    }
    return V1PersistentVolumeClaimStatus;
}());
exports.V1PersistentVolumeClaimStatus = V1PersistentVolumeClaimStatus;
/**
* PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
*/
var V1PersistentVolumeClaimVolumeSource = (function () {
    function V1PersistentVolumeClaimVolumeSource() {
    }
    return V1PersistentVolumeClaimVolumeSource;
}());
exports.V1PersistentVolumeClaimVolumeSource = V1PersistentVolumeClaimVolumeSource;
/**
* PersistentVolumeList is a list of PersistentVolume items.
*/
var V1PersistentVolumeList = (function () {
    function V1PersistentVolumeList() {
    }
    return V1PersistentVolumeList;
}());
exports.V1PersistentVolumeList = V1PersistentVolumeList;
/**
* PersistentVolumeSpec is the specification of a persistent volume.
*/
var V1PersistentVolumeSpec = (function () {
    function V1PersistentVolumeSpec() {
    }
    return V1PersistentVolumeSpec;
}());
exports.V1PersistentVolumeSpec = V1PersistentVolumeSpec;
/**
* PersistentVolumeStatus is the current status of a persistent volume.
*/
var V1PersistentVolumeStatus = (function () {
    function V1PersistentVolumeStatus() {
    }
    return V1PersistentVolumeStatus;
}());
exports.V1PersistentVolumeStatus = V1PersistentVolumeStatus;
/**
* Represents a Photon Controller persistent disk resource.
*/
var V1PhotonPersistentDiskVolumeSource = (function () {
    function V1PhotonPersistentDiskVolumeSource() {
    }
    return V1PhotonPersistentDiskVolumeSource;
}());
exports.V1PhotonPersistentDiskVolumeSource = V1PhotonPersistentDiskVolumeSource;
/**
* Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.
*/
var V1Pod = (function () {
    function V1Pod() {
    }
    return V1Pod;
}());
exports.V1Pod = V1Pod;
/**
* Pod affinity is a group of inter pod affinity scheduling rules.
*/
var V1PodAffinity = (function () {
    function V1PodAffinity() {
    }
    return V1PodAffinity;
}());
exports.V1PodAffinity = V1PodAffinity;
/**
* Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> tches that of any node on which a pod of the set of pods is running
*/
var V1PodAffinityTerm = (function () {
    function V1PodAffinityTerm() {
    }
    return V1PodAffinityTerm;
}());
exports.V1PodAffinityTerm = V1PodAffinityTerm;
/**
* Pod anti affinity is a group of inter pod anti affinity scheduling rules.
*/
var V1PodAntiAffinity = (function () {
    function V1PodAntiAffinity() {
    }
    return V1PodAntiAffinity;
}());
exports.V1PodAntiAffinity = V1PodAntiAffinity;
/**
* PodCondition contains details for the current condition of this pod.
*/
var V1PodCondition = (function () {
    function V1PodCondition() {
    }
    return V1PodCondition;
}());
exports.V1PodCondition = V1PodCondition;
/**
* PodList is a list of Pods.
*/
var V1PodList = (function () {
    function V1PodList() {
    }
    return V1PodList;
}());
exports.V1PodList = V1PodList;
/**
* PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
*/
var V1PodSecurityContext = (function () {
    function V1PodSecurityContext() {
    }
    return V1PodSecurityContext;
}());
exports.V1PodSecurityContext = V1PodSecurityContext;
/**
* PodSpec is a description of a pod.
*/
var V1PodSpec = (function () {
    function V1PodSpec() {
    }
    return V1PodSpec;
}());
exports.V1PodSpec = V1PodSpec;
/**
* PodStatus represents information about the status of a pod. Status may trail the actual state of a system.
*/
var V1PodStatus = (function () {
    function V1PodStatus() {
    }
    return V1PodStatus;
}());
exports.V1PodStatus = V1PodStatus;
/**
* PodTemplate describes a template for creating copies of a predefined pod.
*/
var V1PodTemplate = (function () {
    function V1PodTemplate() {
    }
    return V1PodTemplate;
}());
exports.V1PodTemplate = V1PodTemplate;
/**
* PodTemplateList is a list of PodTemplates.
*/
var V1PodTemplateList = (function () {
    function V1PodTemplateList() {
    }
    return V1PodTemplateList;
}());
exports.V1PodTemplateList = V1PodTemplateList;
/**
* PodTemplateSpec describes the data a pod should have when created from a template
*/
var V1PodTemplateSpec = (function () {
    function V1PodTemplateSpec() {
    }
    return V1PodTemplateSpec;
}());
exports.V1PodTemplateSpec = V1PodTemplateSpec;
/**
* PortworxVolumeSource represents a Portworx volume resource.
*/
var V1PortworxVolumeSource = (function () {
    function V1PortworxVolumeSource() {
    }
    return V1PortworxVolumeSource;
}());
exports.V1PortworxVolumeSource = V1PortworxVolumeSource;
/**
* Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
*/
var V1Preconditions = (function () {
    function V1Preconditions() {
    }
    return V1Preconditions;
}());
exports.V1Preconditions = V1Preconditions;
/**
* An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
*/
var V1PreferredSchedulingTerm = (function () {
    function V1PreferredSchedulingTerm() {
    }
    return V1PreferredSchedulingTerm;
}());
exports.V1PreferredSchedulingTerm = V1PreferredSchedulingTerm;
/**
* Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
*/
var V1Probe = (function () {
    function V1Probe() {
    }
    return V1Probe;
}());
exports.V1Probe = V1Probe;
/**
* Represents a projected volume source
*/
var V1ProjectedVolumeSource = (function () {
    function V1ProjectedVolumeSource() {
    }
    return V1ProjectedVolumeSource;
}());
exports.V1ProjectedVolumeSource = V1ProjectedVolumeSource;
/**
* Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
*/
var V1QuobyteVolumeSource = (function () {
    function V1QuobyteVolumeSource() {
    }
    return V1QuobyteVolumeSource;
}());
exports.V1QuobyteVolumeSource = V1QuobyteVolumeSource;
/**
* Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
*/
var V1RBDVolumeSource = (function () {
    function V1RBDVolumeSource() {
    }
    return V1RBDVolumeSource;
}());
exports.V1RBDVolumeSource = V1RBDVolumeSource;
/**
* ReplicationController represents the configuration of a replication controller.
*/
var V1ReplicationController = (function () {
    function V1ReplicationController() {
    }
    return V1ReplicationController;
}());
exports.V1ReplicationController = V1ReplicationController;
/**
* ReplicationControllerCondition describes the state of a replication controller at a certain point.
*/
var V1ReplicationControllerCondition = (function () {
    function V1ReplicationControllerCondition() {
    }
    return V1ReplicationControllerCondition;
}());
exports.V1ReplicationControllerCondition = V1ReplicationControllerCondition;
/**
* ReplicationControllerList is a collection of replication controllers.
*/
var V1ReplicationControllerList = (function () {
    function V1ReplicationControllerList() {
    }
    return V1ReplicationControllerList;
}());
exports.V1ReplicationControllerList = V1ReplicationControllerList;
/**
* ReplicationControllerSpec is the specification of a replication controller.
*/
var V1ReplicationControllerSpec = (function () {
    function V1ReplicationControllerSpec() {
    }
    return V1ReplicationControllerSpec;
}());
exports.V1ReplicationControllerSpec = V1ReplicationControllerSpec;
/**
* ReplicationControllerStatus represents the current status of a replication controller.
*/
var V1ReplicationControllerStatus = (function () {
    function V1ReplicationControllerStatus() {
    }
    return V1ReplicationControllerStatus;
}());
exports.V1ReplicationControllerStatus = V1ReplicationControllerStatus;
/**
* ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface
*/
var V1ResourceAttributes = (function () {
    function V1ResourceAttributes() {
    }
    return V1ResourceAttributes;
}());
exports.V1ResourceAttributes = V1ResourceAttributes;
/**
* ResourceFieldSelector represents container resources (cpu, memory) and their output format
*/
var V1ResourceFieldSelector = (function () {
    function V1ResourceFieldSelector() {
    }
    return V1ResourceFieldSelector;
}());
exports.V1ResourceFieldSelector = V1ResourceFieldSelector;
/**
* ResourceQuota sets aggregate quota restrictions enforced per namespace
*/
var V1ResourceQuota = (function () {
    function V1ResourceQuota() {
    }
    return V1ResourceQuota;
}());
exports.V1ResourceQuota = V1ResourceQuota;
/**
* ResourceQuotaList is a list of ResourceQuota items.
*/
var V1ResourceQuotaList = (function () {
    function V1ResourceQuotaList() {
    }
    return V1ResourceQuotaList;
}());
exports.V1ResourceQuotaList = V1ResourceQuotaList;
/**
* ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
*/
var V1ResourceQuotaSpec = (function () {
    function V1ResourceQuotaSpec() {
    }
    return V1ResourceQuotaSpec;
}());
exports.V1ResourceQuotaSpec = V1ResourceQuotaSpec;
/**
* ResourceQuotaStatus defines the enforced hard limits and observed use.
*/
var V1ResourceQuotaStatus = (function () {
    function V1ResourceQuotaStatus() {
    }
    return V1ResourceQuotaStatus;
}());
exports.V1ResourceQuotaStatus = V1ResourceQuotaStatus;
/**
* ResourceRequirements describes the compute resource requirements.
*/
var V1ResourceRequirements = (function () {
    function V1ResourceRequirements() {
    }
    return V1ResourceRequirements;
}());
exports.V1ResourceRequirements = V1ResourceRequirements;
/**
* SELinuxOptions are the labels to be applied to the container
*/
var V1SELinuxOptions = (function () {
    function V1SELinuxOptions() {
    }
    return V1SELinuxOptions;
}());
exports.V1SELinuxOptions = V1SELinuxOptions;
/**
* Scale represents a scaling request for a resource.
*/
var V1Scale = (function () {
    function V1Scale() {
    }
    return V1Scale;
}());
exports.V1Scale = V1Scale;
/**
* ScaleIOVolumeSource represents a persistent ScaleIO volume
*/
var V1ScaleIOVolumeSource = (function () {
    function V1ScaleIOVolumeSource() {
    }
    return V1ScaleIOVolumeSource;
}());
exports.V1ScaleIOVolumeSource = V1ScaleIOVolumeSource;
/**
* ScaleSpec describes the attributes of a scale subresource.
*/
var V1ScaleSpec = (function () {
    function V1ScaleSpec() {
    }
    return V1ScaleSpec;
}());
exports.V1ScaleSpec = V1ScaleSpec;
/**
* ScaleStatus represents the current status of a scale subresource.
*/
var V1ScaleStatus = (function () {
    function V1ScaleStatus() {
    }
    return V1ScaleStatus;
}());
exports.V1ScaleStatus = V1ScaleStatus;
/**
* Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes.
*/
var V1Secret = (function () {
    function V1Secret() {
    }
    return V1Secret;
}());
exports.V1Secret = V1Secret;
/**
* SecretEnvSource selects a Secret to populate the environment variables with.  The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
*/
var V1SecretEnvSource = (function () {
    function V1SecretEnvSource() {
    }
    return V1SecretEnvSource;
}());
exports.V1SecretEnvSource = V1SecretEnvSource;
/**
* SecretKeySelector selects a key of a Secret.
*/
var V1SecretKeySelector = (function () {
    function V1SecretKeySelector() {
    }
    return V1SecretKeySelector;
}());
exports.V1SecretKeySelector = V1SecretKeySelector;
/**
* SecretList is a list of Secret.
*/
var V1SecretList = (function () {
    function V1SecretList() {
    }
    return V1SecretList;
}());
exports.V1SecretList = V1SecretList;
/**
* Adapts a secret into a projected volume.  The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
*/
var V1SecretProjection = (function () {
    function V1SecretProjection() {
    }
    return V1SecretProjection;
}());
exports.V1SecretProjection = V1SecretProjection;
/**
* Adapts a Secret into a volume.  The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
*/
var V1SecretVolumeSource = (function () {
    function V1SecretVolumeSource() {
    }
    return V1SecretVolumeSource;
}());
exports.V1SecretVolumeSource = V1SecretVolumeSource;
/**
* SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
*/
var V1SecurityContext = (function () {
    function V1SecurityContext() {
    }
    return V1SecurityContext;
}());
exports.V1SecurityContext = V1SecurityContext;
/**
* SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action
*/
var V1SelfSubjectAccessReview = (function () {
    function V1SelfSubjectAccessReview() {
    }
    return V1SelfSubjectAccessReview;
}());
exports.V1SelfSubjectAccessReview = V1SelfSubjectAccessReview;
/**
* SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
*/
var V1SelfSubjectAccessReviewSpec = (function () {
    function V1SelfSubjectAccessReviewSpec() {
    }
    return V1SelfSubjectAccessReviewSpec;
}());
exports.V1SelfSubjectAccessReviewSpec = V1SelfSubjectAccessReviewSpec;
/**
* ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
*/
var V1ServerAddressByClientCIDR = (function () {
    function V1ServerAddressByClientCIDR() {
    }
    return V1ServerAddressByClientCIDR;
}());
exports.V1ServerAddressByClientCIDR = V1ServerAddressByClientCIDR;
/**
* Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy.
*/
var V1Service = (function () {
    function V1Service() {
    }
    return V1Service;
}());
exports.V1Service = V1Service;
/**
* ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets
*/
var V1ServiceAccount = (function () {
    function V1ServiceAccount() {
    }
    return V1ServiceAccount;
}());
exports.V1ServiceAccount = V1ServiceAccount;
/**
* ServiceAccountList is a list of ServiceAccount objects
*/
var V1ServiceAccountList = (function () {
    function V1ServiceAccountList() {
    }
    return V1ServiceAccountList;
}());
exports.V1ServiceAccountList = V1ServiceAccountList;
/**
* ServiceList holds a list of services.
*/
var V1ServiceList = (function () {
    function V1ServiceList() {
    }
    return V1ServiceList;
}());
exports.V1ServiceList = V1ServiceList;
/**
* ServicePort contains information on service's port.
*/
var V1ServicePort = (function () {
    function V1ServicePort() {
    }
    return V1ServicePort;
}());
exports.V1ServicePort = V1ServicePort;
/**
* ServiceSpec describes the attributes that a user creates on a service.
*/
var V1ServiceSpec = (function () {
    function V1ServiceSpec() {
    }
    return V1ServiceSpec;
}());
exports.V1ServiceSpec = V1ServiceSpec;
/**
* ServiceStatus represents the current status of a service.
*/
var V1ServiceStatus = (function () {
    function V1ServiceStatus() {
    }
    return V1ServiceStatus;
}());
exports.V1ServiceStatus = V1ServiceStatus;
/**
* Status is a return value for calls that don't return other objects.
*/
var V1Status = (function () {
    function V1Status() {
    }
    return V1Status;
}());
exports.V1Status = V1Status;
/**
* StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.
*/
var V1StatusCause = (function () {
    function V1StatusCause() {
    }
    return V1StatusCause;
}());
exports.V1StatusCause = V1StatusCause;
/**
* StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.
*/
var V1StatusDetails = (function () {
    function V1StatusDetails() {
    }
    return V1StatusDetails;
}());
exports.V1StatusDetails = V1StatusDetails;
/**
* StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.  StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.
*/
var V1StorageClass = (function () {
    function V1StorageClass() {
    }
    return V1StorageClass;
}());
exports.V1StorageClass = V1StorageClass;
/**
* StorageClassList is a collection of storage classes.
*/
var V1StorageClassList = (function () {
    function V1StorageClassList() {
    }
    return V1StorageClassList;
}());
exports.V1StorageClassList = V1StorageClassList;
/**
* SubjectAccessReview checks whether or not a user or group can perform an action.
*/
var V1SubjectAccessReview = (function () {
    function V1SubjectAccessReview() {
    }
    return V1SubjectAccessReview;
}());
exports.V1SubjectAccessReview = V1SubjectAccessReview;
/**
* SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
*/
var V1SubjectAccessReviewSpec = (function () {
    function V1SubjectAccessReviewSpec() {
    }
    return V1SubjectAccessReviewSpec;
}());
exports.V1SubjectAccessReviewSpec = V1SubjectAccessReviewSpec;
/**
* SubjectAccessReviewStatus
*/
var V1SubjectAccessReviewStatus = (function () {
    function V1SubjectAccessReviewStatus() {
    }
    return V1SubjectAccessReviewStatus;
}());
exports.V1SubjectAccessReviewStatus = V1SubjectAccessReviewStatus;
/**
* TCPSocketAction describes an action based on opening a socket
*/
var V1TCPSocketAction = (function () {
    function V1TCPSocketAction() {
    }
    return V1TCPSocketAction;
}());
exports.V1TCPSocketAction = V1TCPSocketAction;
/**
* The node this Taint is attached to has the effect \"effect\" on any pod that that does not tolerate the Taint.
*/
var V1Taint = (function () {
    function V1Taint() {
    }
    return V1Taint;
}());
exports.V1Taint = V1Taint;
/**
* TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.
*/
var V1TokenReview = (function () {
    function V1TokenReview() {
    }
    return V1TokenReview;
}());
exports.V1TokenReview = V1TokenReview;
/**
* TokenReviewSpec is a description of the token authentication request.
*/
var V1TokenReviewSpec = (function () {
    function V1TokenReviewSpec() {
    }
    return V1TokenReviewSpec;
}());
exports.V1TokenReviewSpec = V1TokenReviewSpec;
/**
* TokenReviewStatus is the result of the token authentication request.
*/
var V1TokenReviewStatus = (function () {
    function V1TokenReviewStatus() {
    }
    return V1TokenReviewStatus;
}());
exports.V1TokenReviewStatus = V1TokenReviewStatus;
/**
* The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
*/
var V1Toleration = (function () {
    function V1Toleration() {
    }
    return V1Toleration;
}());
exports.V1Toleration = V1Toleration;
/**
* UserInfo holds the information about the user needed to implement the user.Info interface.
*/
var V1UserInfo = (function () {
    function V1UserInfo() {
    }
    return V1UserInfo;
}());
exports.V1UserInfo = V1UserInfo;
/**
* Volume represents a named volume in a pod that may be accessed by any container in the pod.
*/
var V1Volume = (function () {
    function V1Volume() {
    }
    return V1Volume;
}());
exports.V1Volume = V1Volume;
/**
* VolumeMount describes a mounting of a Volume within a container.
*/
var V1VolumeMount = (function () {
    function V1VolumeMount() {
    }
    return V1VolumeMount;
}());
exports.V1VolumeMount = V1VolumeMount;
/**
* Projection that may be projected along with other supported volume types
*/
var V1VolumeProjection = (function () {
    function V1VolumeProjection() {
    }
    return V1VolumeProjection;
}());
exports.V1VolumeProjection = V1VolumeProjection;
/**
* Represents a vSphere volume resource.
*/
var V1VsphereVirtualDiskVolumeSource = (function () {
    function V1VsphereVirtualDiskVolumeSource() {
    }
    return V1VsphereVirtualDiskVolumeSource;
}());
exports.V1VsphereVirtualDiskVolumeSource = V1VsphereVirtualDiskVolumeSource;
/**
* Event represents a single event to a watched resource.
*/
var V1WatchEvent = (function () {
    function V1WatchEvent() {
    }
    return V1WatchEvent;
}());
exports.V1WatchEvent = V1WatchEvent;
/**
* The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
*/
var V1WeightedPodAffinityTerm = (function () {
    function V1WeightedPodAffinityTerm() {
    }
    return V1WeightedPodAffinityTerm;
}());
exports.V1WeightedPodAffinityTerm = V1WeightedPodAffinityTerm;
/**
* ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
*/
var V1alpha1ClusterRole = (function () {
    function V1alpha1ClusterRole() {
    }
    return V1alpha1ClusterRole;
}());
exports.V1alpha1ClusterRole = V1alpha1ClusterRole;
/**
* ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.
*/
var V1alpha1ClusterRoleBinding = (function () {
    function V1alpha1ClusterRoleBinding() {
    }
    return V1alpha1ClusterRoleBinding;
}());
exports.V1alpha1ClusterRoleBinding = V1alpha1ClusterRoleBinding;
/**
* ClusterRoleBindingList is a collection of ClusterRoleBindings
*/
var V1alpha1ClusterRoleBindingList = (function () {
    function V1alpha1ClusterRoleBindingList() {
    }
    return V1alpha1ClusterRoleBindingList;
}());
exports.V1alpha1ClusterRoleBindingList = V1alpha1ClusterRoleBindingList;
/**
* ClusterRoleList is a collection of ClusterRoles
*/
var V1alpha1ClusterRoleList = (function () {
    function V1alpha1ClusterRoleList() {
    }
    return V1alpha1ClusterRoleList;
}());
exports.V1alpha1ClusterRoleList = V1alpha1ClusterRoleList;
/**
* PodPreset is a policy resource that defines additional runtime requirements for a Pod.
*/
var V1alpha1PodPreset = (function () {
    function V1alpha1PodPreset() {
    }
    return V1alpha1PodPreset;
}());
exports.V1alpha1PodPreset = V1alpha1PodPreset;
/**
* PodPresetList is a list of PodPreset objects.
*/
var V1alpha1PodPresetList = (function () {
    function V1alpha1PodPresetList() {
    }
    return V1alpha1PodPresetList;
}());
exports.V1alpha1PodPresetList = V1alpha1PodPresetList;
/**
* PodPresetSpec is a description of a pod injection policy.
*/
var V1alpha1PodPresetSpec = (function () {
    function V1alpha1PodPresetSpec() {
    }
    return V1alpha1PodPresetSpec;
}());
exports.V1alpha1PodPresetSpec = V1alpha1PodPresetSpec;
/**
* PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.
*/
var V1alpha1PolicyRule = (function () {
    function V1alpha1PolicyRule() {
    }
    return V1alpha1PolicyRule;
}());
exports.V1alpha1PolicyRule = V1alpha1PolicyRule;
/**
* Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
*/
var V1alpha1Role = (function () {
    function V1alpha1Role() {
    }
    return V1alpha1Role;
}());
exports.V1alpha1Role = V1alpha1Role;
/**
* RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.
*/
var V1alpha1RoleBinding = (function () {
    function V1alpha1RoleBinding() {
    }
    return V1alpha1RoleBinding;
}());
exports.V1alpha1RoleBinding = V1alpha1RoleBinding;
/**
* RoleBindingList is a collection of RoleBindings
*/
var V1alpha1RoleBindingList = (function () {
    function V1alpha1RoleBindingList() {
    }
    return V1alpha1RoleBindingList;
}());
exports.V1alpha1RoleBindingList = V1alpha1RoleBindingList;
/**
* RoleList is a collection of Roles
*/
var V1alpha1RoleList = (function () {
    function V1alpha1RoleList() {
    }
    return V1alpha1RoleList;
}());
exports.V1alpha1RoleList = V1alpha1RoleList;
/**
* RoleRef contains information that points to the role being used
*/
var V1alpha1RoleRef = (function () {
    function V1alpha1RoleRef() {
    }
    return V1alpha1RoleRef;
}());
exports.V1alpha1RoleRef = V1alpha1RoleRef;
/**
* Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
*/
var V1alpha1Subject = (function () {
    function V1alpha1Subject() {
    }
    return V1alpha1Subject;
}());
exports.V1alpha1Subject = V1alpha1Subject;
/**
* An APIVersion represents a single concrete version of an object model.
*/
var V1beta1APIVersion = (function () {
    function V1beta1APIVersion() {
    }
    return V1beta1APIVersion;
}());
exports.V1beta1APIVersion = V1beta1APIVersion;
/**
* Describes a certificate signing request
*/
var V1beta1CertificateSigningRequest = (function () {
    function V1beta1CertificateSigningRequest() {
    }
    return V1beta1CertificateSigningRequest;
}());
exports.V1beta1CertificateSigningRequest = V1beta1CertificateSigningRequest;
var V1beta1CertificateSigningRequestCondition = (function () {
    function V1beta1CertificateSigningRequestCondition() {
    }
    return V1beta1CertificateSigningRequestCondition;
}());
exports.V1beta1CertificateSigningRequestCondition = V1beta1CertificateSigningRequestCondition;
var V1beta1CertificateSigningRequestList = (function () {
    function V1beta1CertificateSigningRequestList() {
    }
    return V1beta1CertificateSigningRequestList;
}());
exports.V1beta1CertificateSigningRequestList = V1beta1CertificateSigningRequestList;
/**
* This information is immutable after the request is created. Only the Request and Usages fields can be set on creation, other fields are derived by Kubernetes and cannot be modified by users.
*/
var V1beta1CertificateSigningRequestSpec = (function () {
    function V1beta1CertificateSigningRequestSpec() {
    }
    return V1beta1CertificateSigningRequestSpec;
}());
exports.V1beta1CertificateSigningRequestSpec = V1beta1CertificateSigningRequestSpec;
var V1beta1CertificateSigningRequestStatus = (function () {
    function V1beta1CertificateSigningRequestStatus() {
    }
    return V1beta1CertificateSigningRequestStatus;
}());
exports.V1beta1CertificateSigningRequestStatus = V1beta1CertificateSigningRequestStatus;
/**
* ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
*/
var V1beta1ClusterRole = (function () {
    function V1beta1ClusterRole() {
    }
    return V1beta1ClusterRole;
}());
exports.V1beta1ClusterRole = V1beta1ClusterRole;
/**
* ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.
*/
var V1beta1ClusterRoleBinding = (function () {
    function V1beta1ClusterRoleBinding() {
    }
    return V1beta1ClusterRoleBinding;
}());
exports.V1beta1ClusterRoleBinding = V1beta1ClusterRoleBinding;
/**
* ClusterRoleBindingList is a collection of ClusterRoleBindings
*/
var V1beta1ClusterRoleBindingList = (function () {
    function V1beta1ClusterRoleBindingList() {
    }
    return V1beta1ClusterRoleBindingList;
}());
exports.V1beta1ClusterRoleBindingList = V1beta1ClusterRoleBindingList;
/**
* ClusterRoleList is a collection of ClusterRoles
*/
var V1beta1ClusterRoleList = (function () {
    function V1beta1ClusterRoleList() {
    }
    return V1beta1ClusterRoleList;
}());
exports.V1beta1ClusterRoleList = V1beta1ClusterRoleList;
/**
* DaemonSet represents the configuration of a daemon set.
*/
var V1beta1DaemonSet = (function () {
    function V1beta1DaemonSet() {
    }
    return V1beta1DaemonSet;
}());
exports.V1beta1DaemonSet = V1beta1DaemonSet;
/**
* DaemonSetList is a collection of daemon sets.
*/
var V1beta1DaemonSetList = (function () {
    function V1beta1DaemonSetList() {
    }
    return V1beta1DaemonSetList;
}());
exports.V1beta1DaemonSetList = V1beta1DaemonSetList;
/**
* DaemonSetSpec is the specification of a daemon set.
*/
var V1beta1DaemonSetSpec = (function () {
    function V1beta1DaemonSetSpec() {
    }
    return V1beta1DaemonSetSpec;
}());
exports.V1beta1DaemonSetSpec = V1beta1DaemonSetSpec;
/**
* DaemonSetStatus represents the current status of a daemon set.
*/
var V1beta1DaemonSetStatus = (function () {
    function V1beta1DaemonSetStatus() {
    }
    return V1beta1DaemonSetStatus;
}());
exports.V1beta1DaemonSetStatus = V1beta1DaemonSetStatus;
var V1beta1DaemonSetUpdateStrategy = (function () {
    function V1beta1DaemonSetUpdateStrategy() {
    }
    return V1beta1DaemonSetUpdateStrategy;
}());
exports.V1beta1DaemonSetUpdateStrategy = V1beta1DaemonSetUpdateStrategy;
/**
* Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
*/
var V1beta1Eviction = (function () {
    function V1beta1Eviction() {
    }
    return V1beta1Eviction;
}());
exports.V1beta1Eviction = V1beta1Eviction;
/**
* FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
*/
var V1beta1FSGroupStrategyOptions = (function () {
    function V1beta1FSGroupStrategyOptions() {
    }
    return V1beta1FSGroupStrategyOptions;
}());
exports.V1beta1FSGroupStrategyOptions = V1beta1FSGroupStrategyOptions;
/**
* HTTPIngressPath associates a path regex with a backend. Incoming urls matching the path are forwarded to the backend.
*/
var V1beta1HTTPIngressPath = (function () {
    function V1beta1HTTPIngressPath() {
    }
    return V1beta1HTTPIngressPath;
}());
exports.V1beta1HTTPIngressPath = V1beta1HTTPIngressPath;
/**
* HTTPIngressRuleValue is a list of http selectors pointing to backends. In the example: http://<host>/<path>?<searchpart> -> backend where where parts of the url correspond to RFC 3986, this resource will be used to match against everything after the last '/' and before the first '?' or '#'.
*/
var V1beta1HTTPIngressRuleValue = (function () {
    function V1beta1HTTPIngressRuleValue() {
    }
    return V1beta1HTTPIngressRuleValue;
}());
exports.V1beta1HTTPIngressRuleValue = V1beta1HTTPIngressRuleValue;
/**
* Host Port Range defines a range of host ports that will be enabled by a policy for pods to use.  It requires both the start and end to be defined.
*/
var V1beta1HostPortRange = (function () {
    function V1beta1HostPortRange() {
    }
    return V1beta1HostPortRange;
}());
exports.V1beta1HostPortRange = V1beta1HostPortRange;
/**
* ID Range provides a min/max of an allowed range of IDs.
*/
var V1beta1IDRange = (function () {
    function V1beta1IDRange() {
    }
    return V1beta1IDRange;
}());
exports.V1beta1IDRange = V1beta1IDRange;
/**
* Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
*/
var V1beta1Ingress = (function () {
    function V1beta1Ingress() {
    }
    return V1beta1Ingress;
}());
exports.V1beta1Ingress = V1beta1Ingress;
/**
* IngressBackend describes all endpoints for a given service and port.
*/
var V1beta1IngressBackend = (function () {
    function V1beta1IngressBackend() {
    }
    return V1beta1IngressBackend;
}());
exports.V1beta1IngressBackend = V1beta1IngressBackend;
/**
* IngressList is a collection of Ingress.
*/
var V1beta1IngressList = (function () {
    function V1beta1IngressList() {
    }
    return V1beta1IngressList;
}());
exports.V1beta1IngressList = V1beta1IngressList;
/**
* IngressRule represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching IngressRuleValue.
*/
var V1beta1IngressRule = (function () {
    function V1beta1IngressRule() {
    }
    return V1beta1IngressRule;
}());
exports.V1beta1IngressRule = V1beta1IngressRule;
/**
* IngressSpec describes the Ingress the user wishes to exist.
*/
var V1beta1IngressSpec = (function () {
    function V1beta1IngressSpec() {
    }
    return V1beta1IngressSpec;
}());
exports.V1beta1IngressSpec = V1beta1IngressSpec;
/**
* IngressStatus describe the current state of the Ingress.
*/
var V1beta1IngressStatus = (function () {
    function V1beta1IngressStatus() {
    }
    return V1beta1IngressStatus;
}());
exports.V1beta1IngressStatus = V1beta1IngressStatus;
/**
* IngressTLS describes the transport layer security associated with an Ingress.
*/
var V1beta1IngressTLS = (function () {
    function V1beta1IngressTLS() {
    }
    return V1beta1IngressTLS;
}());
exports.V1beta1IngressTLS = V1beta1IngressTLS;
/**
* LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.
*/
var V1beta1LocalSubjectAccessReview = (function () {
    function V1beta1LocalSubjectAccessReview() {
    }
    return V1beta1LocalSubjectAccessReview;
}());
exports.V1beta1LocalSubjectAccessReview = V1beta1LocalSubjectAccessReview;
var V1beta1NetworkPolicy = (function () {
    function V1beta1NetworkPolicy() {
    }
    return V1beta1NetworkPolicy;
}());
exports.V1beta1NetworkPolicy = V1beta1NetworkPolicy;
/**
* This NetworkPolicyIngressRule matches traffic if and only if the traffic matches both ports AND from.
*/
var V1beta1NetworkPolicyIngressRule = (function () {
    function V1beta1NetworkPolicyIngressRule() {
    }
    return V1beta1NetworkPolicyIngressRule;
}());
exports.V1beta1NetworkPolicyIngressRule = V1beta1NetworkPolicyIngressRule;
/**
* Network Policy List is a list of NetworkPolicy objects.
*/
var V1beta1NetworkPolicyList = (function () {
    function V1beta1NetworkPolicyList() {
    }
    return V1beta1NetworkPolicyList;
}());
exports.V1beta1NetworkPolicyList = V1beta1NetworkPolicyList;
var V1beta1NetworkPolicyPeer = (function () {
    function V1beta1NetworkPolicyPeer() {
    }
    return V1beta1NetworkPolicyPeer;
}());
exports.V1beta1NetworkPolicyPeer = V1beta1NetworkPolicyPeer;
var V1beta1NetworkPolicyPort = (function () {
    function V1beta1NetworkPolicyPort() {
    }
    return V1beta1NetworkPolicyPort;
}());
exports.V1beta1NetworkPolicyPort = V1beta1NetworkPolicyPort;
var V1beta1NetworkPolicySpec = (function () {
    function V1beta1NetworkPolicySpec() {
    }
    return V1beta1NetworkPolicySpec;
}());
exports.V1beta1NetworkPolicySpec = V1beta1NetworkPolicySpec;
/**
* NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface
*/
var V1beta1NonResourceAttributes = (function () {
    function V1beta1NonResourceAttributes() {
    }
    return V1beta1NonResourceAttributes;
}());
exports.V1beta1NonResourceAttributes = V1beta1NonResourceAttributes;
/**
* PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
*/
var V1beta1PodDisruptionBudget = (function () {
    function V1beta1PodDisruptionBudget() {
    }
    return V1beta1PodDisruptionBudget;
}());
exports.V1beta1PodDisruptionBudget = V1beta1PodDisruptionBudget;
/**
* PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
*/
var V1beta1PodDisruptionBudgetList = (function () {
    function V1beta1PodDisruptionBudgetList() {
    }
    return V1beta1PodDisruptionBudgetList;
}());
exports.V1beta1PodDisruptionBudgetList = V1beta1PodDisruptionBudgetList;
/**
* PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
*/
var V1beta1PodDisruptionBudgetSpec = (function () {
    function V1beta1PodDisruptionBudgetSpec() {
    }
    return V1beta1PodDisruptionBudgetSpec;
}());
exports.V1beta1PodDisruptionBudgetSpec = V1beta1PodDisruptionBudgetSpec;
/**
* PodDisruptionBudgetStatus represents information about the status of a PodDisruptionBudget. Status may trail the actual state of a system.
*/
var V1beta1PodDisruptionBudgetStatus = (function () {
    function V1beta1PodDisruptionBudgetStatus() {
    }
    return V1beta1PodDisruptionBudgetStatus;
}());
exports.V1beta1PodDisruptionBudgetStatus = V1beta1PodDisruptionBudgetStatus;
/**
* Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container.
*/
var V1beta1PodSecurityPolicy = (function () {
    function V1beta1PodSecurityPolicy() {
    }
    return V1beta1PodSecurityPolicy;
}());
exports.V1beta1PodSecurityPolicy = V1beta1PodSecurityPolicy;
/**
* Pod Security Policy List is a list of PodSecurityPolicy objects.
*/
var V1beta1PodSecurityPolicyList = (function () {
    function V1beta1PodSecurityPolicyList() {
    }
    return V1beta1PodSecurityPolicyList;
}());
exports.V1beta1PodSecurityPolicyList = V1beta1PodSecurityPolicyList;
/**
* Pod Security Policy Spec defines the policy enforced.
*/
var V1beta1PodSecurityPolicySpec = (function () {
    function V1beta1PodSecurityPolicySpec() {
    }
    return V1beta1PodSecurityPolicySpec;
}());
exports.V1beta1PodSecurityPolicySpec = V1beta1PodSecurityPolicySpec;
/**
* PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.
*/
var V1beta1PolicyRule = (function () {
    function V1beta1PolicyRule() {
    }
    return V1beta1PolicyRule;
}());
exports.V1beta1PolicyRule = V1beta1PolicyRule;
/**
* ReplicaSet represents the configuration of a ReplicaSet.
*/
var V1beta1ReplicaSet = (function () {
    function V1beta1ReplicaSet() {
    }
    return V1beta1ReplicaSet;
}());
exports.V1beta1ReplicaSet = V1beta1ReplicaSet;
/**
* ReplicaSetCondition describes the state of a replica set at a certain point.
*/
var V1beta1ReplicaSetCondition = (function () {
    function V1beta1ReplicaSetCondition() {
    }
    return V1beta1ReplicaSetCondition;
}());
exports.V1beta1ReplicaSetCondition = V1beta1ReplicaSetCondition;
/**
* ReplicaSetList is a collection of ReplicaSets.
*/
var V1beta1ReplicaSetList = (function () {
    function V1beta1ReplicaSetList() {
    }
    return V1beta1ReplicaSetList;
}());
exports.V1beta1ReplicaSetList = V1beta1ReplicaSetList;
/**
* ReplicaSetSpec is the specification of a ReplicaSet.
*/
var V1beta1ReplicaSetSpec = (function () {
    function V1beta1ReplicaSetSpec() {
    }
    return V1beta1ReplicaSetSpec;
}());
exports.V1beta1ReplicaSetSpec = V1beta1ReplicaSetSpec;
/**
* ReplicaSetStatus represents the current status of a ReplicaSet.
*/
var V1beta1ReplicaSetStatus = (function () {
    function V1beta1ReplicaSetStatus() {
    }
    return V1beta1ReplicaSetStatus;
}());
exports.V1beta1ReplicaSetStatus = V1beta1ReplicaSetStatus;
/**
* ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface
*/
var V1beta1ResourceAttributes = (function () {
    function V1beta1ResourceAttributes() {
    }
    return V1beta1ResourceAttributes;
}());
exports.V1beta1ResourceAttributes = V1beta1ResourceAttributes;
/**
* Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
*/
var V1beta1Role = (function () {
    function V1beta1Role() {
    }
    return V1beta1Role;
}());
exports.V1beta1Role = V1beta1Role;
/**
* RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.
*/
var V1beta1RoleBinding = (function () {
    function V1beta1RoleBinding() {
    }
    return V1beta1RoleBinding;
}());
exports.V1beta1RoleBinding = V1beta1RoleBinding;
/**
* RoleBindingList is a collection of RoleBindings
*/
var V1beta1RoleBindingList = (function () {
    function V1beta1RoleBindingList() {
    }
    return V1beta1RoleBindingList;
}());
exports.V1beta1RoleBindingList = V1beta1RoleBindingList;
/**
* RoleList is a collection of Roles
*/
var V1beta1RoleList = (function () {
    function V1beta1RoleList() {
    }
    return V1beta1RoleList;
}());
exports.V1beta1RoleList = V1beta1RoleList;
/**
* RoleRef contains information that points to the role being used
*/
var V1beta1RoleRef = (function () {
    function V1beta1RoleRef() {
    }
    return V1beta1RoleRef;
}());
exports.V1beta1RoleRef = V1beta1RoleRef;
/**
* Spec to control the desired behavior of daemon set rolling update.
*/
var V1beta1RollingUpdateDaemonSet = (function () {
    function V1beta1RollingUpdateDaemonSet() {
    }
    return V1beta1RollingUpdateDaemonSet;
}());
exports.V1beta1RollingUpdateDaemonSet = V1beta1RollingUpdateDaemonSet;
/**
* Run A sUser Strategy Options defines the strategy type and any options used to create the strategy.
*/
var V1beta1RunAsUserStrategyOptions = (function () {
    function V1beta1RunAsUserStrategyOptions() {
    }
    return V1beta1RunAsUserStrategyOptions;
}());
exports.V1beta1RunAsUserStrategyOptions = V1beta1RunAsUserStrategyOptions;
/**
* SELinux  Strategy Options defines the strategy type and any options used to create the strategy.
*/
var V1beta1SELinuxStrategyOptions = (function () {
    function V1beta1SELinuxStrategyOptions() {
    }
    return V1beta1SELinuxStrategyOptions;
}());
exports.V1beta1SELinuxStrategyOptions = V1beta1SELinuxStrategyOptions;
/**
* SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action
*/
var V1beta1SelfSubjectAccessReview = (function () {
    function V1beta1SelfSubjectAccessReview() {
    }
    return V1beta1SelfSubjectAccessReview;
}());
exports.V1beta1SelfSubjectAccessReview = V1beta1SelfSubjectAccessReview;
/**
* SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
*/
var V1beta1SelfSubjectAccessReviewSpec = (function () {
    function V1beta1SelfSubjectAccessReviewSpec() {
    }
    return V1beta1SelfSubjectAccessReviewSpec;
}());
exports.V1beta1SelfSubjectAccessReviewSpec = V1beta1SelfSubjectAccessReviewSpec;
/**
* StatefulSet represents a set of pods with consistent identities. Identities are defined as:  - Network: A single stable DNS and hostname.  - Storage: As many VolumeClaims as requested. The StatefulSet guarantees that a given network identity will always map to the same storage identity.
*/
var V1beta1StatefulSet = (function () {
    function V1beta1StatefulSet() {
    }
    return V1beta1StatefulSet;
}());
exports.V1beta1StatefulSet = V1beta1StatefulSet;
/**
* StatefulSetList is a collection of StatefulSets.
*/
var V1beta1StatefulSetList = (function () {
    function V1beta1StatefulSetList() {
    }
    return V1beta1StatefulSetList;
}());
exports.V1beta1StatefulSetList = V1beta1StatefulSetList;
/**
* A StatefulSetSpec is the specification of a StatefulSet.
*/
var V1beta1StatefulSetSpec = (function () {
    function V1beta1StatefulSetSpec() {
    }
    return V1beta1StatefulSetSpec;
}());
exports.V1beta1StatefulSetSpec = V1beta1StatefulSetSpec;
/**
* StatefulSetStatus represents the current state of a StatefulSet.
*/
var V1beta1StatefulSetStatus = (function () {
    function V1beta1StatefulSetStatus() {
    }
    return V1beta1StatefulSetStatus;
}());
exports.V1beta1StatefulSetStatus = V1beta1StatefulSetStatus;
/**
* StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.  StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.
*/
var V1beta1StorageClass = (function () {
    function V1beta1StorageClass() {
    }
    return V1beta1StorageClass;
}());
exports.V1beta1StorageClass = V1beta1StorageClass;
/**
* StorageClassList is a collection of storage classes.
*/
var V1beta1StorageClassList = (function () {
    function V1beta1StorageClassList() {
    }
    return V1beta1StorageClassList;
}());
exports.V1beta1StorageClassList = V1beta1StorageClassList;
/**
* Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
*/
var V1beta1Subject = (function () {
    function V1beta1Subject() {
    }
    return V1beta1Subject;
}());
exports.V1beta1Subject = V1beta1Subject;
/**
* SubjectAccessReview checks whether or not a user or group can perform an action.
*/
var V1beta1SubjectAccessReview = (function () {
    function V1beta1SubjectAccessReview() {
    }
    return V1beta1SubjectAccessReview;
}());
exports.V1beta1SubjectAccessReview = V1beta1SubjectAccessReview;
/**
* SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set
*/
var V1beta1SubjectAccessReviewSpec = (function () {
    function V1beta1SubjectAccessReviewSpec() {
    }
    return V1beta1SubjectAccessReviewSpec;
}());
exports.V1beta1SubjectAccessReviewSpec = V1beta1SubjectAccessReviewSpec;
/**
* SubjectAccessReviewStatus
*/
var V1beta1SubjectAccessReviewStatus = (function () {
    function V1beta1SubjectAccessReviewStatus() {
    }
    return V1beta1SubjectAccessReviewStatus;
}());
exports.V1beta1SubjectAccessReviewStatus = V1beta1SubjectAccessReviewStatus;
/**
* SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.
*/
var V1beta1SupplementalGroupsStrategyOptions = (function () {
    function V1beta1SupplementalGroupsStrategyOptions() {
    }
    return V1beta1SupplementalGroupsStrategyOptions;
}());
exports.V1beta1SupplementalGroupsStrategyOptions = V1beta1SupplementalGroupsStrategyOptions;
/**
* A ThirdPartyResource is a generic representation of a resource, it is used by add-ons and plugins to add new resource types to the API.  It consists of one or more Versions of the api.
*/
var V1beta1ThirdPartyResource = (function () {
    function V1beta1ThirdPartyResource() {
    }
    return V1beta1ThirdPartyResource;
}());
exports.V1beta1ThirdPartyResource = V1beta1ThirdPartyResource;
/**
* ThirdPartyResourceList is a list of ThirdPartyResources.
*/
var V1beta1ThirdPartyResourceList = (function () {
    function V1beta1ThirdPartyResourceList() {
    }
    return V1beta1ThirdPartyResourceList;
}());
exports.V1beta1ThirdPartyResourceList = V1beta1ThirdPartyResourceList;
/**
* TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.
*/
var V1beta1TokenReview = (function () {
    function V1beta1TokenReview() {
    }
    return V1beta1TokenReview;
}());
exports.V1beta1TokenReview = V1beta1TokenReview;
/**
* TokenReviewSpec is a description of the token authentication request.
*/
var V1beta1TokenReviewSpec = (function () {
    function V1beta1TokenReviewSpec() {
    }
    return V1beta1TokenReviewSpec;
}());
exports.V1beta1TokenReviewSpec = V1beta1TokenReviewSpec;
/**
* TokenReviewStatus is the result of the token authentication request.
*/
var V1beta1TokenReviewStatus = (function () {
    function V1beta1TokenReviewStatus() {
    }
    return V1beta1TokenReviewStatus;
}());
exports.V1beta1TokenReviewStatus = V1beta1TokenReviewStatus;
/**
* UserInfo holds the information about the user needed to implement the user.Info interface.
*/
var V1beta1UserInfo = (function () {
    function V1beta1UserInfo() {
    }
    return V1beta1UserInfo;
}());
exports.V1beta1UserInfo = V1beta1UserInfo;
/**
* CronJob represents the configuration of a single cron job.
*/
var V2alpha1CronJob = (function () {
    function V2alpha1CronJob() {
    }
    return V2alpha1CronJob;
}());
exports.V2alpha1CronJob = V2alpha1CronJob;
/**
* CronJobList is a collection of cron jobs.
*/
var V2alpha1CronJobList = (function () {
    function V2alpha1CronJobList() {
    }
    return V2alpha1CronJobList;
}());
exports.V2alpha1CronJobList = V2alpha1CronJobList;
/**
* CronJobSpec describes how the job execution will look like and when it will actually run.
*/
var V2alpha1CronJobSpec = (function () {
    function V2alpha1CronJobSpec() {
    }
    return V2alpha1CronJobSpec;
}());
exports.V2alpha1CronJobSpec = V2alpha1CronJobSpec;
/**
* CronJobStatus represents the current state of a cron job.
*/
var V2alpha1CronJobStatus = (function () {
    function V2alpha1CronJobStatus() {
    }
    return V2alpha1CronJobStatus;
}());
exports.V2alpha1CronJobStatus = V2alpha1CronJobStatus;
/**
* CrossVersionObjectReference contains enough information to let you identify the referred resource.
*/
var V2alpha1CrossVersionObjectReference = (function () {
    function V2alpha1CrossVersionObjectReference() {
    }
    return V2alpha1CrossVersionObjectReference;
}());
exports.V2alpha1CrossVersionObjectReference = V2alpha1CrossVersionObjectReference;
/**
* HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified.
*/
var V2alpha1HorizontalPodAutoscaler = (function () {
    function V2alpha1HorizontalPodAutoscaler() {
    }
    return V2alpha1HorizontalPodAutoscaler;
}());
exports.V2alpha1HorizontalPodAutoscaler = V2alpha1HorizontalPodAutoscaler;
/**
* HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.
*/
var V2alpha1HorizontalPodAutoscalerList = (function () {
    function V2alpha1HorizontalPodAutoscalerList() {
    }
    return V2alpha1HorizontalPodAutoscalerList;
}());
exports.V2alpha1HorizontalPodAutoscalerList = V2alpha1HorizontalPodAutoscalerList;
/**
* HorizontalPodAutoscalerSpec describes the desired functionality of the HorizontalPodAutoscaler.
*/
var V2alpha1HorizontalPodAutoscalerSpec = (function () {
    function V2alpha1HorizontalPodAutoscalerSpec() {
    }
    return V2alpha1HorizontalPodAutoscalerSpec;
}());
exports.V2alpha1HorizontalPodAutoscalerSpec = V2alpha1HorizontalPodAutoscalerSpec;
/**
* HorizontalPodAutoscalerStatus describes the current status of a horizontal pod autoscaler.
*/
var V2alpha1HorizontalPodAutoscalerStatus = (function () {
    function V2alpha1HorizontalPodAutoscalerStatus() {
    }
    return V2alpha1HorizontalPodAutoscalerStatus;
}());
exports.V2alpha1HorizontalPodAutoscalerStatus = V2alpha1HorizontalPodAutoscalerStatus;
/**
* JobTemplateSpec describes the data a Job should have when created from a template
*/
var V2alpha1JobTemplateSpec = (function () {
    function V2alpha1JobTemplateSpec() {
    }
    return V2alpha1JobTemplateSpec;
}());
exports.V2alpha1JobTemplateSpec = V2alpha1JobTemplateSpec;
/**
* MetricSpec specifies how to scale based on a single metric (only `type` and one other matching field should be set at once).
*/
var V2alpha1MetricSpec = (function () {
    function V2alpha1MetricSpec() {
    }
    return V2alpha1MetricSpec;
}());
exports.V2alpha1MetricSpec = V2alpha1MetricSpec;
/**
* MetricStatus describes the last-read state of a single metric.
*/
var V2alpha1MetricStatus = (function () {
    function V2alpha1MetricStatus() {
    }
    return V2alpha1MetricStatus;
}());
exports.V2alpha1MetricStatus = V2alpha1MetricStatus;
/**
* ObjectMetricSource indicates how to scale on a metric describing a kubernetes object (for example, hits-per-second on an Ingress object).
*/
var V2alpha1ObjectMetricSource = (function () {
    function V2alpha1ObjectMetricSource() {
    }
    return V2alpha1ObjectMetricSource;
}());
exports.V2alpha1ObjectMetricSource = V2alpha1ObjectMetricSource;
/**
* ObjectMetricStatus indicates the current value of a metric describing a kubernetes object (for example, hits-per-second on an Ingress object).
*/
var V2alpha1ObjectMetricStatus = (function () {
    function V2alpha1ObjectMetricStatus() {
    }
    return V2alpha1ObjectMetricStatus;
}());
exports.V2alpha1ObjectMetricStatus = V2alpha1ObjectMetricStatus;
/**
* PodsMetricSource indicates how to scale on a metric describing each pod in the current scale target (for example, transactions-processed-per-second). The values will be averaged together before being compared to the target value.
*/
var V2alpha1PodsMetricSource = (function () {
    function V2alpha1PodsMetricSource() {
    }
    return V2alpha1PodsMetricSource;
}());
exports.V2alpha1PodsMetricSource = V2alpha1PodsMetricSource;
/**
* PodsMetricStatus indicates the current value of a metric describing each pod in the current scale target (for example, transactions-processed-per-second).
*/
var V2alpha1PodsMetricStatus = (function () {
    function V2alpha1PodsMetricStatus() {
    }
    return V2alpha1PodsMetricStatus;
}());
exports.V2alpha1PodsMetricStatus = V2alpha1PodsMetricStatus;
/**
* ResourceMetricSource indicates how to scale on a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  The values will be averaged together before being compared to the target.  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.  Only one \"target\" type should be set.
*/
var V2alpha1ResourceMetricSource = (function () {
    function V2alpha1ResourceMetricSource() {
    }
    return V2alpha1ResourceMetricSource;
}());
exports.V2alpha1ResourceMetricSource = V2alpha1ResourceMetricSource;
/**
* ResourceMetricStatus indicates the current value of a resource metric known to Kubernetes, as specified in requests and limits, describing each pod in the current scale target (e.g. CPU or memory).  Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source.
*/
var V2alpha1ResourceMetricStatus = (function () {
    function V2alpha1ResourceMetricStatus() {
    }
    return V2alpha1ResourceMetricStatus;
}());
exports.V2alpha1ResourceMetricStatus = V2alpha1ResourceMetricStatus;
/**
* Info contains versioning information. how we'll want to distribute that information.
*/
var VersionInfo = (function () {
    function VersionInfo() {
    }
    return VersionInfo;
}());
exports.VersionInfo = VersionInfo;
var HttpBasicAuth = (function () {
    function HttpBasicAuth() {
    }
    HttpBasicAuth.prototype.applyToRequest = function (requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    };
    return HttpBasicAuth;
}());
exports.HttpBasicAuth = HttpBasicAuth;
var ApiKeyAuth = (function () {
    function ApiKeyAuth(location, paramName) {
        this.location = location;
        this.paramName = paramName;
    }
    ApiKeyAuth.prototype.applyToRequest = function (requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    };
    return ApiKeyAuth;
}());
exports.ApiKeyAuth = ApiKeyAuth;
var OAuth = (function () {
    function OAuth() {
    }
    OAuth.prototype.applyToRequest = function (requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    };
    return OAuth;
}());
exports.OAuth = OAuth;
var VoidAuth = (function () {
    function VoidAuth() {
    }
    VoidAuth.prototype.applyToRequest = function (_) {
        // Do nothing
    };
    return VoidAuth;
}());
exports.VoidAuth = VoidAuth;
var ApisApiApiKeys;
(function (ApisApiApiKeys) {
    ApisApiApiKeys[ApisApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(ApisApiApiKeys = exports.ApisApiApiKeys || (exports.ApisApiApiKeys = {}));
var ApisApi = (function () {
    function ApisApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(ApisApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    ApisApi.prototype.setApiKey = function (key, value) {
        this.authentications[ApisApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get available API versions
     */
    ApisApi.prototype.getAPIVersions = function () {
        var localVarPath = this.basePath + '/apis/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return ApisApi;
}());
exports.ApisApi = ApisApi;
var AppsApiApiKeys;
(function (AppsApiApiKeys) {
    AppsApiApiKeys[AppsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AppsApiApiKeys = exports.AppsApiApiKeys || (exports.AppsApiApiKeys = {}));
var AppsApi = (function () {
    function AppsApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(AppsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    AppsApi.prototype.setApiKey = function (key, value) {
        this.authentications[AppsApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    AppsApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/apps/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return AppsApi;
}());
exports.AppsApi = AppsApi;
var Apps_v1beta1ApiApiKeys;
(function (Apps_v1beta1ApiApiKeys) {
    Apps_v1beta1ApiApiKeys[Apps_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Apps_v1beta1ApiApiKeys = exports.Apps_v1beta1ApiApiKeys || (exports.Apps_v1beta1ApiApiKeys = {}));
var Apps_v1beta1Api = (function () {
    function Apps_v1beta1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Apps_v1beta1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Apps_v1beta1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Apps_v1beta1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.createNamespacedDeployment = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create rollback of a DeploymentRollback
     * @param name name of the DeploymentRollback
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.createNamespacedDeploymentRollbackRollback = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/rollback'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNamespacedDeploymentRollbackRollback.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeploymentRollbackRollback.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeploymentRollbackRollback.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.createNamespacedStatefulSet = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Apps_v1beta1Api.prototype.deleteCollectionNamespacedDeployment = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Apps_v1beta1Api.prototype.deleteCollectionNamespacedStatefulSet = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Apps_v1beta1Api.prototype.deleteNamespacedDeployment = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Apps_v1beta1Api.prototype.deleteNamespacedStatefulSet = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Apps_v1beta1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Deployment
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Apps_v1beta1Api.prototype.listDeploymentForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/deployments';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Apps_v1beta1Api.prototype.listNamespacedDeployment = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Apps_v1beta1Api.prototype.listNamespacedStatefulSet = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind StatefulSet
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Apps_v1beta1Api.prototype.listStatefulSetForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/statefulsets';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.patchNamespacedDeployment = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.patchNamespacedDeploymentStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.patchNamespacedScaleScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedScaleScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedScaleScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedScaleScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.patchNamespacedStatefulSet = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.patchNamespacedStatefulSetStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Apps_v1beta1Api.prototype.readNamespacedDeployment = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.readNamespacedDeploymentStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.readNamespacedScaleScale = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedScaleScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedScaleScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Apps_v1beta1Api.prototype.readNamespacedStatefulSet = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.readNamespacedStatefulSetStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.replaceNamespacedDeployment = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.replaceNamespacedDeploymentStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.replaceNamespacedScaleScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedScaleScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedScaleScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedScaleScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.replaceNamespacedStatefulSet = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified StatefulSet
     * @param name name of the StatefulSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Apps_v1beta1Api.prototype.replaceNamespacedStatefulSetStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedStatefulSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Apps_v1beta1Api;
}());
exports.Apps_v1beta1Api = Apps_v1beta1Api;
var AuthenticationApiApiKeys;
(function (AuthenticationApiApiKeys) {
    AuthenticationApiApiKeys[AuthenticationApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AuthenticationApiApiKeys = exports.AuthenticationApiApiKeys || (exports.AuthenticationApiApiKeys = {}));
var AuthenticationApi = (function () {
    function AuthenticationApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(AuthenticationApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    AuthenticationApi.prototype.setApiKey = function (key, value) {
        this.authentications[AuthenticationApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    AuthenticationApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/authentication.k8s.io/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return AuthenticationApi;
}());
exports.AuthenticationApi = AuthenticationApi;
var Authentication_v1ApiApiKeys;
(function (Authentication_v1ApiApiKeys) {
    Authentication_v1ApiApiKeys[Authentication_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Authentication_v1ApiApiKeys = exports.Authentication_v1ApiApiKeys || (exports.Authentication_v1ApiApiKeys = {}));
var Authentication_v1Api = (function () {
    function Authentication_v1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Authentication_v1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Authentication_v1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Authentication_v1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a TokenReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Authentication_v1Api.prototype.createTokenReview = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/authentication.k8s.io/v1/tokenreviews';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTokenReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Authentication_v1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/authentication.k8s.io/v1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Authentication_v1Api;
}());
exports.Authentication_v1Api = Authentication_v1Api;
var Authentication_v1beta1ApiApiKeys;
(function (Authentication_v1beta1ApiApiKeys) {
    Authentication_v1beta1ApiApiKeys[Authentication_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Authentication_v1beta1ApiApiKeys = exports.Authentication_v1beta1ApiApiKeys || (exports.Authentication_v1beta1ApiApiKeys = {}));
var Authentication_v1beta1Api = (function () {
    function Authentication_v1beta1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Authentication_v1beta1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Authentication_v1beta1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Authentication_v1beta1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a TokenReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Authentication_v1beta1Api.prototype.createTokenReview = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/authentication.k8s.io/v1beta1/tokenreviews';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTokenReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Authentication_v1beta1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/authentication.k8s.io/v1beta1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Authentication_v1beta1Api;
}());
exports.Authentication_v1beta1Api = Authentication_v1beta1Api;
var AuthorizationApiApiKeys;
(function (AuthorizationApiApiKeys) {
    AuthorizationApiApiKeys[AuthorizationApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AuthorizationApiApiKeys = exports.AuthorizationApiApiKeys || (exports.AuthorizationApiApiKeys = {}));
var AuthorizationApi = (function () {
    function AuthorizationApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(AuthorizationApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    AuthorizationApi.prototype.setApiKey = function (key, value) {
        this.authentications[AuthorizationApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    AuthorizationApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return AuthorizationApi;
}());
exports.AuthorizationApi = AuthorizationApi;
var Authorization_v1ApiApiKeys;
(function (Authorization_v1ApiApiKeys) {
    Authorization_v1ApiApiKeys[Authorization_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Authorization_v1ApiApiKeys = exports.Authorization_v1ApiApiKeys || (exports.Authorization_v1ApiApiKeys = {}));
var Authorization_v1Api = (function () {
    function Authorization_v1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Authorization_v1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Authorization_v1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Authorization_v1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a LocalSubjectAccessReview
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Authorization_v1Api.prototype.createNamespacedLocalSubjectAccessReview = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/namespaces/{namespace}/localsubjectaccessreviews'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedLocalSubjectAccessReview.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedLocalSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a SelfSubjectAccessReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Authorization_v1Api.prototype.createSelfSubjectAccessReview = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/selfsubjectaccessreviews';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSelfSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a SubjectAccessReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Authorization_v1Api.prototype.createSubjectAccessReview = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/subjectaccessreviews';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Authorization_v1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/v1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Authorization_v1Api;
}());
exports.Authorization_v1Api = Authorization_v1Api;
var Authorization_v1beta1ApiApiKeys;
(function (Authorization_v1beta1ApiApiKeys) {
    Authorization_v1beta1ApiApiKeys[Authorization_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Authorization_v1beta1ApiApiKeys = exports.Authorization_v1beta1ApiApiKeys || (exports.Authorization_v1beta1ApiApiKeys = {}));
var Authorization_v1beta1Api = (function () {
    function Authorization_v1beta1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Authorization_v1beta1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Authorization_v1beta1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Authorization_v1beta1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a LocalSubjectAccessReview
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Authorization_v1beta1Api.prototype.createNamespacedLocalSubjectAccessReview = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/namespaces/{namespace}/localsubjectaccessreviews'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedLocalSubjectAccessReview.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedLocalSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a SelfSubjectAccessReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Authorization_v1beta1Api.prototype.createSelfSubjectAccessReview = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/selfsubjectaccessreviews';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSelfSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a SubjectAccessReview
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Authorization_v1beta1Api.prototype.createSubjectAccessReview = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/subjectaccessreviews';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSubjectAccessReview.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Authorization_v1beta1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/authorization.k8s.io/v1beta1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Authorization_v1beta1Api;
}());
exports.Authorization_v1beta1Api = Authorization_v1beta1Api;
var AutoscalingApiApiKeys;
(function (AutoscalingApiApiKeys) {
    AutoscalingApiApiKeys[AutoscalingApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(AutoscalingApiApiKeys = exports.AutoscalingApiApiKeys || (exports.AutoscalingApiApiKeys = {}));
var AutoscalingApi = (function () {
    function AutoscalingApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(AutoscalingApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    AutoscalingApi.prototype.setApiKey = function (key, value) {
        this.authentications[AutoscalingApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    AutoscalingApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/autoscaling/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return AutoscalingApi;
}());
exports.AutoscalingApi = AutoscalingApi;
var Autoscaling_v1ApiApiKeys;
(function (Autoscaling_v1ApiApiKeys) {
    Autoscaling_v1ApiApiKeys[Autoscaling_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Autoscaling_v1ApiApiKeys = exports.Autoscaling_v1ApiApiKeys || (exports.Autoscaling_v1ApiApiKeys = {}));
var Autoscaling_v1Api = (function () {
    function Autoscaling_v1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Autoscaling_v1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Autoscaling_v1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Autoscaling_v1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v1Api.prototype.createNamespacedHorizontalPodAutoscaler = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Autoscaling_v1Api.prototype.deleteCollectionNamespacedHorizontalPodAutoscaler = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Autoscaling_v1Api.prototype.deleteNamespacedHorizontalPodAutoscaler = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Autoscaling_v1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Autoscaling_v1Api.prototype.listHorizontalPodAutoscalerForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/horizontalpodautoscalers';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Autoscaling_v1Api.prototype.listNamespacedHorizontalPodAutoscaler = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v1Api.prototype.patchNamespacedHorizontalPodAutoscaler = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v1Api.prototype.patchNamespacedHorizontalPodAutoscalerStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Autoscaling_v1Api.prototype.readNamespacedHorizontalPodAutoscaler = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v1Api.prototype.readNamespacedHorizontalPodAutoscalerStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v1Api.prototype.replaceNamespacedHorizontalPodAutoscaler = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v1Api.prototype.replaceNamespacedHorizontalPodAutoscalerStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Autoscaling_v1Api;
}());
exports.Autoscaling_v1Api = Autoscaling_v1Api;
var Autoscaling_v2alpha1ApiApiKeys;
(function (Autoscaling_v2alpha1ApiApiKeys) {
    Autoscaling_v2alpha1ApiApiKeys[Autoscaling_v2alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Autoscaling_v2alpha1ApiApiKeys = exports.Autoscaling_v2alpha1ApiApiKeys || (exports.Autoscaling_v2alpha1ApiApiKeys = {}));
var Autoscaling_v2alpha1Api = (function () {
    function Autoscaling_v2alpha1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Autoscaling_v2alpha1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Autoscaling_v2alpha1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Autoscaling_v2alpha1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v2alpha1Api.prototype.createNamespacedHorizontalPodAutoscaler = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Autoscaling_v2alpha1Api.prototype.deleteCollectionNamespacedHorizontalPodAutoscaler = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Autoscaling_v2alpha1Api.prototype.deleteNamespacedHorizontalPodAutoscaler = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Autoscaling_v2alpha1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Autoscaling_v2alpha1Api.prototype.listHorizontalPodAutoscalerForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/horizontalpodautoscalers';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Autoscaling_v2alpha1Api.prototype.listNamespacedHorizontalPodAutoscaler = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v2alpha1Api.prototype.patchNamespacedHorizontalPodAutoscaler = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v2alpha1Api.prototype.patchNamespacedHorizontalPodAutoscalerStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Autoscaling_v2alpha1Api.prototype.readNamespacedHorizontalPodAutoscaler = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v2alpha1Api.prototype.readNamespacedHorizontalPodAutoscalerStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v2alpha1Api.prototype.replaceNamespacedHorizontalPodAutoscaler = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedHorizontalPodAutoscaler.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified HorizontalPodAutoscaler
     * @param name name of the HorizontalPodAutoscaler
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Autoscaling_v2alpha1Api.prototype.replaceNamespacedHorizontalPodAutoscalerStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/autoscaling/v2alpha1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedHorizontalPodAutoscalerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Autoscaling_v2alpha1Api;
}());
exports.Autoscaling_v2alpha1Api = Autoscaling_v2alpha1Api;
var BatchApiApiKeys;
(function (BatchApiApiKeys) {
    BatchApiApiKeys[BatchApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(BatchApiApiKeys = exports.BatchApiApiKeys || (exports.BatchApiApiKeys = {}));
var BatchApi = (function () {
    function BatchApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(BatchApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    BatchApi.prototype.setApiKey = function (key, value) {
        this.authentications[BatchApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    BatchApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/batch/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return BatchApi;
}());
exports.BatchApi = BatchApi;
var Batch_v1ApiApiKeys;
(function (Batch_v1ApiApiKeys) {
    Batch_v1ApiApiKeys[Batch_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Batch_v1ApiApiKeys = exports.Batch_v1ApiApiKeys || (exports.Batch_v1ApiApiKeys = {}));
var Batch_v1Api = (function () {
    function Batch_v1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Batch_v1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Batch_v1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Batch_v1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v1Api.prototype.createNamespacedJob = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v1Api.prototype.deleteCollectionNamespacedJob = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Batch_v1Api.prototype.deleteNamespacedJob = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Batch_v1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/batch/v1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Job
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v1Api.prototype.listJobForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v1/jobs';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v1Api.prototype.listNamespacedJob = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v1Api.prototype.patchNamespacedJob = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v1Api.prototype.patchNamespacedJobStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Batch_v1Api.prototype.readNamespacedJob = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v1Api.prototype.readNamespacedJobStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v1Api.prototype.replaceNamespacedJob = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified Job
     * @param name name of the Job
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v1Api.prototype.replaceNamespacedJobStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Batch_v1Api;
}());
exports.Batch_v1Api = Batch_v1Api;
var Batch_v2alpha1ApiApiKeys;
(function (Batch_v2alpha1ApiApiKeys) {
    Batch_v2alpha1ApiApiKeys[Batch_v2alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Batch_v2alpha1ApiApiKeys = exports.Batch_v2alpha1ApiApiKeys || (exports.Batch_v2alpha1ApiApiKeys = {}));
var Batch_v2alpha1Api = (function () {
    function Batch_v2alpha1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Batch_v2alpha1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Batch_v2alpha1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Batch_v2alpha1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.createNamespacedCronJob = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.createNamespacedScheduledJob = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedScheduledJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedScheduledJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v2alpha1Api.prototype.deleteCollectionNamespacedCronJob = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v2alpha1Api.prototype.deleteCollectionNamespacedScheduledJob = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedScheduledJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Batch_v2alpha1Api.prototype.deleteNamespacedCronJob = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ScheduledJob
     * @param name name of the ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Batch_v2alpha1Api.prototype.deleteNamespacedScheduledJob = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedScheduledJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedScheduledJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedScheduledJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Batch_v2alpha1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind CronJob
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v2alpha1Api.prototype.listCronJobForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/cronjobs';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v2alpha1Api.prototype.listNamespacedCronJob = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v2alpha1Api.prototype.listNamespacedScheduledJob = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedScheduledJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ScheduledJob
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Batch_v2alpha1Api.prototype.listScheduledJobForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/scheduledjobs';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.patchNamespacedCronJob = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.patchNamespacedCronJobStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ScheduledJob
     * @param name name of the ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.patchNamespacedScheduledJob = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedScheduledJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedScheduledJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedScheduledJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified ScheduledJob
     * @param name name of the ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.patchNamespacedScheduledJobStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedScheduledJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedScheduledJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedScheduledJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Batch_v2alpha1Api.prototype.readNamespacedCronJob = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.readNamespacedCronJobStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ScheduledJob
     * @param name name of the ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Batch_v2alpha1Api.prototype.readNamespacedScheduledJob = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedScheduledJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedScheduledJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified ScheduledJob
     * @param name name of the ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.readNamespacedScheduledJobStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedScheduledJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedScheduledJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.replaceNamespacedCronJob = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCronJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCronJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCronJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified CronJob
     * @param name name of the CronJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.replaceNamespacedCronJobStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedCronJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ScheduledJob
     * @param name name of the ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.replaceNamespacedScheduledJob = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedScheduledJob.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedScheduledJob.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedScheduledJob.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified ScheduledJob
     * @param name name of the ScheduledJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Batch_v2alpha1Api.prototype.replaceNamespacedScheduledJobStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/batch/v2alpha1/namespaces/{namespace}/scheduledjobs/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedScheduledJobStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedScheduledJobStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedScheduledJobStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Batch_v2alpha1Api;
}());
exports.Batch_v2alpha1Api = Batch_v2alpha1Api;
var CertificatesApiApiKeys;
(function (CertificatesApiApiKeys) {
    CertificatesApiApiKeys[CertificatesApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(CertificatesApiApiKeys = exports.CertificatesApiApiKeys || (exports.CertificatesApiApiKeys = {}));
var CertificatesApi = (function () {
    function CertificatesApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(CertificatesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    CertificatesApi.prototype.setApiKey = function (key, value) {
        this.authentications[CertificatesApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    CertificatesApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return CertificatesApi;
}());
exports.CertificatesApi = CertificatesApi;
var Certificates_v1beta1ApiApiKeys;
(function (Certificates_v1beta1ApiApiKeys) {
    Certificates_v1beta1ApiApiKeys[Certificates_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Certificates_v1beta1ApiApiKeys = exports.Certificates_v1beta1ApiApiKeys || (exports.Certificates_v1beta1ApiApiKeys = {}));
var Certificates_v1beta1Api = (function () {
    function Certificates_v1beta1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Certificates_v1beta1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Certificates_v1beta1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Certificates_v1beta1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Certificates_v1beta1Api.prototype.createCertificateSigningRequest = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Certificates_v1beta1Api.prototype.deleteCertificateSigningRequest = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteCertificateSigningRequest.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of CertificateSigningRequest
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Certificates_v1beta1Api.prototype.deleteCollectionCertificateSigningRequest = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Certificates_v1beta1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind CertificateSigningRequest
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Certificates_v1beta1Api.prototype.listCertificateSigningRequest = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Certificates_v1beta1Api.prototype.patchCertificateSigningRequest = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchCertificateSigningRequest.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Certificates_v1beta1Api.prototype.readCertificateSigningRequest = function (name, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Certificates_v1beta1Api.prototype.replaceCertificateSigningRequest = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCertificateSigningRequest.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceCertificateSigningRequest.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace approval of the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Certificates_v1beta1Api.prototype.replaceCertificateSigningRequestApproval = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/approval'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCertificateSigningRequestApproval.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceCertificateSigningRequestApproval.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified CertificateSigningRequest
     * @param name name of the CertificateSigningRequest
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Certificates_v1beta1Api.prototype.replaceCertificateSigningRequestStatus = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceCertificateSigningRequestStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceCertificateSigningRequestStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Certificates_v1beta1Api;
}());
exports.Certificates_v1beta1Api = Certificates_v1beta1Api;
var CoreApiApiKeys;
(function (CoreApiApiKeys) {
    CoreApiApiKeys[CoreApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(CoreApiApiKeys = exports.CoreApiApiKeys || (exports.CoreApiApiKeys = {}));
var CoreApi = (function () {
    function CoreApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(CoreApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    CoreApi.prototype.setApiKey = function (key, value) {
        this.authentications[CoreApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get available API versions
     */
    CoreApi.prototype.getAPIVersions = function () {
        var localVarPath = this.basePath + '/api/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return CoreApi;
}());
exports.CoreApi = CoreApi;
var Core_v1ApiApiKeys;
(function (Core_v1ApiApiKeys) {
    Core_v1ApiApiKeys[Core_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Core_v1ApiApiKeys = exports.Core_v1ApiApiKeys || (exports.Core_v1ApiApiKeys = {}));
var Core_v1Api = (function () {
    function Core_v1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Core_v1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Core_v1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Core_v1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * connect DELETE requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectDeleteNamespacedPodProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectDeleteNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect DELETE requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectDeleteNamespacedPodProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectDeleteNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect DELETE requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectDeleteNamespacedServiceProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectDeleteNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect DELETE requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectDeleteNamespacedServiceProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect DELETE requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectDeleteNodeProxy = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect DELETE requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectDeleteNodeProxyWithPath = function (name, path, path2) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectDeleteNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectDeleteNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to attach of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param container The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @param stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @param stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @param tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     */
    Core_v1Api.prototype.connectGetNamespacedPodAttach = function (name, namespace, container, stderr, stdin, stdout, tty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/attach'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodAttach.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodAttach.');
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (stderr !== undefined) {
            queryParameters['stderr'] = stderr;
        }
        if (stdin !== undefined) {
            queryParameters['stdin'] = stdin;
        }
        if (stdout !== undefined) {
            queryParameters['stdout'] = stdout;
        }
        if (tty !== undefined) {
            queryParameters['tty'] = tty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to exec of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param command Command is the remote command to execute. argv array. Not executed within a shell.
     * @param container Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param stderr Redirect the standard error stream of the pod for this call. Defaults to true.
     * @param stdin Redirect the standard input stream of the pod for this call. Defaults to false.
     * @param stdout Redirect the standard output stream of the pod for this call. Defaults to true.
     * @param tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     */
    Core_v1Api.prototype.connectGetNamespacedPodExec = function (name, namespace, command, container, stderr, stdin, stdout, tty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/exec'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodExec.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodExec.');
        }
        if (command !== undefined) {
            queryParameters['command'] = command;
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (stderr !== undefined) {
            queryParameters['stderr'] = stderr;
        }
        if (stdin !== undefined) {
            queryParameters['stdin'] = stdin;
        }
        if (stdout !== undefined) {
            queryParameters['stdout'] = stdout;
        }
        if (tty !== undefined) {
            queryParameters['tty'] = tty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to portforward of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param ports List of ports to forward Required when using WebSockets
     */
    Core_v1Api.prototype.connectGetNamespacedPodPortforward = function (name, namespace, ports) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/portforward'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodPortforward.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodPortforward.');
        }
        if (ports !== undefined) {
            queryParameters['ports'] = ports;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectGetNamespacedPodProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectGetNamespacedPodProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectGetNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectGetNamespacedServiceProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectGetNamespacedServiceProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectGetNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectGetNodeProxy = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect GET requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectGetNodeProxyWithPath = function (name, path, path2) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectGetNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectGetNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect HEAD requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectHeadNamespacedPodProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectHeadNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect HEAD requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectHeadNamespacedPodProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectHeadNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect HEAD requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectHeadNamespacedServiceProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectHeadNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect HEAD requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectHeadNamespacedServiceProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectHeadNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect HEAD requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectHeadNodeProxy = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect HEAD requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectHeadNodeProxyWithPath = function (name, path, path2) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectHeadNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectHeadNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect OPTIONS requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectOptionsNamespacedPodProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectOptionsNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect OPTIONS requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectOptionsNamespacedPodProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectOptionsNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect OPTIONS requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectOptionsNamespacedServiceProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectOptionsNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect OPTIONS requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectOptionsNamespacedServiceProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect OPTIONS requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectOptionsNodeProxy = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect OPTIONS requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectOptionsNodeProxyWithPath = function (name, path, path2) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectOptionsNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectOptionsNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to attach of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param container The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * @param stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * @param stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * @param tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     */
    Core_v1Api.prototype.connectPostNamespacedPodAttach = function (name, namespace, container, stderr, stdin, stdout, tty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/attach'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodAttach.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodAttach.');
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (stderr !== undefined) {
            queryParameters['stderr'] = stderr;
        }
        if (stdin !== undefined) {
            queryParameters['stdin'] = stdin;
        }
        if (stdout !== undefined) {
            queryParameters['stdout'] = stdout;
        }
        if (tty !== undefined) {
            queryParameters['tty'] = tty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to exec of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param command Command is the remote command to execute. argv array. Not executed within a shell.
     * @param container Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * @param stderr Redirect the standard error stream of the pod for this call. Defaults to true.
     * @param stdin Redirect the standard input stream of the pod for this call. Defaults to false.
     * @param stdout Redirect the standard output stream of the pod for this call. Defaults to true.
     * @param tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     */
    Core_v1Api.prototype.connectPostNamespacedPodExec = function (name, namespace, command, container, stderr, stdin, stdout, tty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/exec'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodExec.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodExec.');
        }
        if (command !== undefined) {
            queryParameters['command'] = command;
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (stderr !== undefined) {
            queryParameters['stderr'] = stderr;
        }
        if (stdin !== undefined) {
            queryParameters['stdin'] = stdin;
        }
        if (stdout !== undefined) {
            queryParameters['stdout'] = stdout;
        }
        if (tty !== undefined) {
            queryParameters['tty'] = tty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to portforward of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param ports List of ports to forward Required when using WebSockets
     */
    Core_v1Api.prototype.connectPostNamespacedPodPortforward = function (name, namespace, ports) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/portforward'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodPortforward.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodPortforward.');
        }
        if (ports !== undefined) {
            queryParameters['ports'] = ports;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectPostNamespacedPodProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectPostNamespacedPodProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPostNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectPostNamespacedServiceProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectPostNamespacedServiceProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPostNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectPostNodeProxy = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect POST requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectPostNodeProxyWithPath = function (name, path, path2) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPostNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPostNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect PUT requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectPutNamespacedPodProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNamespacedPodProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPutNamespacedPodProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect PUT requests to proxy of Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to pod.
     */
    Core_v1Api.prototype.connectPutNamespacedPodProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPutNamespacedPodProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect PUT requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectPutNamespacedServiceProxy = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNamespacedServiceProxy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPutNamespacedServiceProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect PUT requests to proxy of Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     */
    Core_v1Api.prototype.connectPutNamespacedServiceProxyWithPath = function (name, namespace, path, path2) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPutNamespacedServiceProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect PUT requests to proxy of Node
     * @param name name of the Node
     * @param path Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectPutNodeProxy = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNodeProxy.');
        }
        if (path !== undefined) {
            queryParameters['path'] = path;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * connect PUT requests to proxy of Node
     * @param name name of the Node
     * @param path path to the resource
     * @param path2 Path is the URL path to use for the current proxy request to node.
     */
    Core_v1Api.prototype.connectPutNodeProxyWithPath = function (name, path, path2) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/proxy/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling connectPutNodeProxyWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling connectPutNodeProxyWithPath.');
        }
        if (path2 !== undefined) {
            queryParameters['path'] = path2;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespace = function (body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Binding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedBinding = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/bindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create binding of a Binding
     * @param name name of the Binding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedBindingBinding = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/binding'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNamespacedBindingBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedBindingBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedBindingBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedConfigMap = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedConfigMap.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedEndpoints = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedEndpoints.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create an Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedEvent = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create eviction of an Eviction
     * @param name name of the Eviction
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedEvictionEviction = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/eviction'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNamespacedEvictionEviction.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedEvictionEviction.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedEvictionEviction.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedLimitRange = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedLimitRange.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedPersistentVolumeClaim = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedPod = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPod.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedPodTemplate = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPodTemplate.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedReplicationController = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedReplicationController.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedResourceQuota = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedResourceQuota.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedSecret = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedSecret.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedService = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNamespacedServiceAccount = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedServiceAccount.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createNode = function (body, pretty) {
        var localVarPath = this.basePath + '/api/v1/nodes';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.createPersistentVolume = function (body, pretty) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedConfigMap = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedEndpoints = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedEvent = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedLimitRange = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedPersistentVolumeClaim = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedPod = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedPodTemplate = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedReplicationController = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedResourceQuota = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedSecret = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNamespacedServiceAccount = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Node
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionNode = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/nodes';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of PersistentVolume
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.deleteCollectionPersistentVolume = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespace = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespace.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ConfigMap
     * @param name name of the ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedConfigMap = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedConfigMap.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedConfigMap.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete Endpoints
     * @param name name of the Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedEndpoints = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedEndpoints.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedEndpoints.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete an Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedEvent = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a LimitRange
     * @param name name of the LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedLimitRange = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedLimitRange.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedLimitRange.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedPersistentVolumeClaim = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedPod = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPod.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a PodTemplate
     * @param name name of the PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedPodTemplate = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPodTemplate.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPodTemplate.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedReplicationController = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedReplicationController.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedReplicationController.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedResourceQuota = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedResourceQuota.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedResourceQuota.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Secret
     * @param name name of the Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedSecret = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedSecret.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedSecret.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.deleteNamespacedService = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ServiceAccount
     * @param name name of the ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNamespacedServiceAccount = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedServiceAccount.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedServiceAccount.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deleteNode = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNode.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Core_v1Api.prototype.deletePersistentVolume = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deletePersistentVolume.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deletePersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Core_v1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/api/v1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list objects of kind ComponentStatus
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listComponentStatus = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/componentstatuses';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ConfigMap
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listConfigMapForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/configmaps';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Endpoints
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listEndpointsForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/endpoints';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Event
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listEventForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/events';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind LimitRange
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listLimitRangeForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/limitranges';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Namespace
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespace = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedConfigMap = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedEndpoints = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedEvent = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedLimitRange = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedPersistentVolumeClaim = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedPod = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedPodTemplate = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedReplicationController = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedResourceQuota = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedSecret = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedService = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNamespacedServiceAccount = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Node
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listNode = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/nodes';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PersistentVolume
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listPersistentVolume = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PersistentVolumeClaim
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listPersistentVolumeClaimForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumeclaims';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Pod
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listPodForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/pods';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PodTemplate
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listPodTemplateForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/podtemplates';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ReplicationController
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listReplicationControllerForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/replicationcontrollers';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ResourceQuota
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listResourceQuotaForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/resourcequotas';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Secret
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listSecretForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/secrets';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ServiceAccount
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listServiceAccountForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/serviceaccounts';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Service
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Core_v1Api.prototype.listServiceForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/api/v1/services';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespace = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespace.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespaceStatus = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespaceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespaceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ConfigMap
     * @param name name of the ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedConfigMap = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedConfigMap.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedConfigMap.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Endpoints
     * @param name name of the Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedEndpoints = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedEndpoints.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedEndpoints.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedEvent = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified LimitRange
     * @param name name of the LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedLimitRange = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedLimitRange.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedLimitRange.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedPersistentVolumeClaim = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedPersistentVolumeClaimStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedPod = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPod.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedPodStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified PodTemplate
     * @param name name of the PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedPodTemplate = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodTemplate.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodTemplate.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedReplicationController = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicationController.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicationController.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedReplicationControllerStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicationControllerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedResourceQuota = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedResourceQuota.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedResourceQuota.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedResourceQuotaStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedResourceQuotaStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedScaleScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedScaleScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedScaleScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedScaleScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Secret
     * @param name name of the Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedSecret = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedSecret.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedSecret.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedService = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ServiceAccount
     * @param name name of the ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedServiceAccount = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedServiceAccount.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedServiceAccount.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNamespacedServiceStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedServiceStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedServiceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNode = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNode.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchNodeStatus = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNodeStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNodeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchPersistentVolume = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPersistentVolume.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.patchPersistentVolumeStatus = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPersistentVolumeStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPersistentVolumeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy DELETE requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyDELETENamespacedPod = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyDELETENamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyDELETENamespacedPod.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy DELETE requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyDELETENamespacedPodWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyDELETENamespacedPodWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyDELETENamespacedPodWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyDELETENamespacedPodWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy DELETE requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyDELETENamespacedService = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyDELETENamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyDELETENamespacedService.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy DELETE requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyDELETENamespacedServiceWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyDELETENamespacedServiceWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyDELETENamespacedServiceWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyDELETENamespacedServiceWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy DELETE requests to Node
     * @param name name of the Node
     */
    Core_v1Api.prototype.proxyDELETENode = function (name) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyDELETENode.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy DELETE requests to Node
     * @param name name of the Node
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyDELETENodeWithPath = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyDELETENodeWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyDELETENodeWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy GET requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyGETNamespacedPod = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyGETNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyGETNamespacedPod.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy GET requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyGETNamespacedPodWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyGETNamespacedPodWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyGETNamespacedPodWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyGETNamespacedPodWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy GET requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyGETNamespacedService = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyGETNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyGETNamespacedService.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy GET requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyGETNamespacedServiceWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyGETNamespacedServiceWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyGETNamespacedServiceWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyGETNamespacedServiceWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy GET requests to Node
     * @param name name of the Node
     */
    Core_v1Api.prototype.proxyGETNode = function (name) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyGETNode.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy GET requests to Node
     * @param name name of the Node
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyGETNodeWithPath = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyGETNodeWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyGETNodeWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy HEAD requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyHEADNamespacedPod = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyHEADNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyHEADNamespacedPod.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy HEAD requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyHEADNamespacedPodWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyHEADNamespacedPodWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyHEADNamespacedPodWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyHEADNamespacedPodWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy HEAD requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyHEADNamespacedService = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyHEADNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyHEADNamespacedService.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy HEAD requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyHEADNamespacedServiceWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyHEADNamespacedServiceWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyHEADNamespacedServiceWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyHEADNamespacedServiceWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy HEAD requests to Node
     * @param name name of the Node
     */
    Core_v1Api.prototype.proxyHEADNode = function (name) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyHEADNode.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy HEAD requests to Node
     * @param name name of the Node
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyHEADNodeWithPath = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyHEADNodeWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyHEADNodeWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy OPTIONS requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyOPTIONSNamespacedPod = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyOPTIONSNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyOPTIONSNamespacedPod.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy OPTIONS requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyOPTIONSNamespacedPodWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyOPTIONSNamespacedPodWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyOPTIONSNamespacedPodWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyOPTIONSNamespacedPodWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy OPTIONS requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyOPTIONSNamespacedService = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyOPTIONSNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyOPTIONSNamespacedService.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy OPTIONS requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyOPTIONSNamespacedServiceWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyOPTIONSNamespacedServiceWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyOPTIONSNamespacedServiceWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyOPTIONSNamespacedServiceWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy OPTIONS requests to Node
     * @param name name of the Node
     */
    Core_v1Api.prototype.proxyOPTIONSNode = function (name) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyOPTIONSNode.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy OPTIONS requests to Node
     * @param name name of the Node
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyOPTIONSNodeWithPath = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyOPTIONSNodeWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyOPTIONSNodeWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'OPTIONS',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PATCH requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyPATCHNamespacedPod = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPATCHNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPATCHNamespacedPod.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PATCH requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPATCHNamespacedPodWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPATCHNamespacedPodWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPATCHNamespacedPodWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPATCHNamespacedPodWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PATCH requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyPATCHNamespacedService = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPATCHNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPATCHNamespacedService.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PATCH requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPATCHNamespacedServiceWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPATCHNamespacedServiceWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPATCHNamespacedServiceWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPATCHNamespacedServiceWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PATCH requests to Node
     * @param name name of the Node
     */
    Core_v1Api.prototype.proxyPATCHNode = function (name) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPATCHNode.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PATCH requests to Node
     * @param name name of the Node
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPATCHNodeWithPath = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPATCHNodeWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPATCHNodeWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy POST requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyPOSTNamespacedPod = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPOSTNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPOSTNamespacedPod.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy POST requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPOSTNamespacedPodWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPOSTNamespacedPodWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPOSTNamespacedPodWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPOSTNamespacedPodWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy POST requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyPOSTNamespacedService = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPOSTNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPOSTNamespacedService.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy POST requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPOSTNamespacedServiceWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPOSTNamespacedServiceWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPOSTNamespacedServiceWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPOSTNamespacedServiceWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy POST requests to Node
     * @param name name of the Node
     */
    Core_v1Api.prototype.proxyPOSTNode = function (name) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPOSTNode.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy POST requests to Node
     * @param name name of the Node
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPOSTNodeWithPath = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPOSTNodeWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPOSTNodeWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PUT requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyPUTNamespacedPod = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPUTNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPUTNamespacedPod.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PUT requests to Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPUTNamespacedPodWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPUTNamespacedPodWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPUTNamespacedPodWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPUTNamespacedPodWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PUT requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     */
    Core_v1Api.prototype.proxyPUTNamespacedService = function (name, namespace) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPUTNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPUTNamespacedService.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PUT requests to Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPUTNamespacedServiceWithPath = function (name, namespace, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPUTNamespacedServiceWithPath.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling proxyPUTNamespacedServiceWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPUTNamespacedServiceWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PUT requests to Node
     * @param name name of the Node
     */
    Core_v1Api.prototype.proxyPUTNode = function (name) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPUTNode.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * proxy PUT requests to Node
     * @param name name of the Node
     * @param path path to the resource
     */
    Core_v1Api.prototype.proxyPUTNodeWithPath = function (name, path) {
        var localVarPath = this.basePath + '/api/v1/proxy/nodes/{name}/{path}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'path' + '}', String(path));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling proxyPUTNodeWithPath.');
        }
        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling proxyPUTNodeWithPath.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ComponentStatus
     * @param name name of the ComponentStatus
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readComponentStatus = function (name, pretty) {
        var localVarPath = this.basePath + '/api/v1/componentstatuses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readComponentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Namespace
     * @param name name of the Namespace
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespace = function (name, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified Namespace
     * @param name name of the Namespace
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readNamespaceStatus = function (name, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespaceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ConfigMap
     * @param name name of the ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedConfigMap = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedConfigMap.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Endpoints
     * @param name name of the Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedEndpoints = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedEndpoints.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedEvent = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified LimitRange
     * @param name name of the LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedLimitRange = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedLimitRange.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedPersistentVolumeClaim = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readNamespacedPersistentVolumeClaimStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPersistentVolumeClaimStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedPod = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read log of the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param container The container for which to stream logs. Defaults to only container if there is one container in the pod.
     * @param follow Follow the log stream of the pod. Defaults to false.
     * @param limitBytes If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param previous Return previous terminated container logs. Defaults to false.
     * @param sinceSeconds A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
     * @param tailLines If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
     * @param timestamps If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
     */
    Core_v1Api.prototype.readNamespacedPodLog = function (name, namespace, container, follow, limitBytes, pretty, previous, sinceSeconds, tailLines, timestamps) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/log'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodLog.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodLog.');
        }
        if (container !== undefined) {
            queryParameters['container'] = container;
        }
        if (follow !== undefined) {
            queryParameters['follow'] = follow;
        }
        if (limitBytes !== undefined) {
            queryParameters['limitBytes'] = limitBytes;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (previous !== undefined) {
            queryParameters['previous'] = previous;
        }
        if (sinceSeconds !== undefined) {
            queryParameters['sinceSeconds'] = sinceSeconds;
        }
        if (tailLines !== undefined) {
            queryParameters['tailLines'] = tailLines;
        }
        if (timestamps !== undefined) {
            queryParameters['timestamps'] = timestamps;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readNamespacedPodStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified PodTemplate
     * @param name name of the PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedPodTemplate = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodTemplate.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedReplicationController = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicationController.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readNamespacedReplicationControllerStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicationControllerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedResourceQuota = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedResourceQuota.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readNamespacedResourceQuotaStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedResourceQuotaStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readNamespacedScaleScale = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedScaleScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedScaleScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Secret
     * @param name name of the Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedSecret = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedSecret.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedService = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ServiceAccount
     * @param name name of the ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNamespacedServiceAccount = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedServiceAccount.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readNamespacedServiceStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedServiceStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Node
     * @param name name of the Node
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readNode = function (name, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified Node
     * @param name name of the Node
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readNodeStatus = function (name, pretty) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNodeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Core_v1Api.prototype.readPersistentVolume = function (name, pretty, exact, _export) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.readPersistentVolumeStatus = function (name, pretty) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPersistentVolumeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespace = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespace.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespace.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace finalize of the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespaceFinalize = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{name}/finalize'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespaceFinalize.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespaceFinalize.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified Namespace
     * @param name name of the Namespace
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespaceStatus = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespaceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespaceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ConfigMap
     * @param name name of the ConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedConfigMap = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/configmaps/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedConfigMap.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedConfigMap.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedConfigMap.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Endpoints
     * @param name name of the Endpoints
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedEndpoints = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/endpoints/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedEndpoints.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedEndpoints.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedEndpoints.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Event
     * @param name name of the Event
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedEvent = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/events/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedEvent.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedEvent.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedEvent.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified LimitRange
     * @param name name of the LimitRange
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedLimitRange = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/limitranges/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedLimitRange.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedLimitRange.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedLimitRange.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedPersistentVolumeClaim = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPersistentVolumeClaim.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified PersistentVolumeClaim
     * @param name name of the PersistentVolumeClaim
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedPersistentVolumeClaimStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedPod = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPod.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPod.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPod.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified Pod
     * @param name name of the Pod
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedPodStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/pods/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified PodTemplate
     * @param name name of the PodTemplate
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedPodTemplate = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/podtemplates/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodTemplate.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodTemplate.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodTemplate.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedReplicationController = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicationController.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicationController.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicationController.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified ReplicationController
     * @param name name of the ReplicationController
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedReplicationControllerStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicationControllerStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedResourceQuota = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedResourceQuota.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedResourceQuota.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedResourceQuota.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified ResourceQuota
     * @param name name of the ResourceQuota
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedResourceQuotaStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedResourceQuotaStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedScaleScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedScaleScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedScaleScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedScaleScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Secret
     * @param name name of the Secret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedSecret = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/secrets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedSecret.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedSecret.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedSecret.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedService = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedService.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedService.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedService.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ServiceAccount
     * @param name name of the ServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedServiceAccount = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedServiceAccount.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedServiceAccount.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedServiceAccount.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified Service
     * @param name name of the Service
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNamespacedServiceStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/namespaces/{namespace}/services/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedServiceStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedServiceStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedServiceStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNode = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNode.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNode.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified Node
     * @param name name of the Node
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replaceNodeStatus = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/nodes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNodeStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNodeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replacePersistentVolume = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePersistentVolume.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePersistentVolume.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified PersistentVolume
     * @param name name of the PersistentVolume
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Core_v1Api.prototype.replacePersistentVolumeStatus = function (name, body, pretty) {
        var localVarPath = this.basePath + '/api/v1/persistentvolumes/{name}/status'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePersistentVolumeStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePersistentVolumeStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Core_v1Api;
}());
exports.Core_v1Api = Core_v1Api;
var ExtensionsApiApiKeys;
(function (ExtensionsApiApiKeys) {
    ExtensionsApiApiKeys[ExtensionsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(ExtensionsApiApiKeys = exports.ExtensionsApiApiKeys || (exports.ExtensionsApiApiKeys = {}));
var ExtensionsApi = (function () {
    function ExtensionsApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(ExtensionsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    ExtensionsApi.prototype.setApiKey = function (key, value) {
        this.authentications[ExtensionsApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    ExtensionsApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/extensions/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return ExtensionsApi;
}());
exports.ExtensionsApi = ExtensionsApi;
var Extensions_v1beta1ApiApiKeys;
(function (Extensions_v1beta1ApiApiKeys) {
    Extensions_v1beta1ApiApiKeys[Extensions_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Extensions_v1beta1ApiApiKeys = exports.Extensions_v1beta1ApiApiKeys || (exports.Extensions_v1beta1ApiApiKeys = {}));
var Extensions_v1beta1Api = (function () {
    function Extensions_v1beta1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Extensions_v1beta1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Extensions_v1beta1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Extensions_v1beta1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.createNamespacedDaemonSet = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.createNamespacedDeployment = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create rollback of a DeploymentRollback
     * @param name name of the DeploymentRollback
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.createNamespacedDeploymentRollbackRollback = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/rollback'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNamespacedDeploymentRollbackRollback.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedDeploymentRollbackRollback.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedDeploymentRollbackRollback.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create an Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.createNamespacedIngress = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedIngress.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.createNamespacedNetworkPolicy = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.createNamespacedReplicaSet = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.createPodSecurityPolicy = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ThirdPartyResource
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.createThirdPartyResource = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/thirdpartyresources';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createThirdPartyResource.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.deleteCollectionNamespacedDaemonSet = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.deleteCollectionNamespacedDeployment = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.deleteCollectionNamespacedIngress = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.deleteCollectionNamespacedNetworkPolicy = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.deleteCollectionNamespacedReplicaSet = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.deleteCollectionPodSecurityPolicy = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ThirdPartyResource
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.deleteCollectionThirdPartyResource = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/thirdpartyresources';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Extensions_v1beta1Api.prototype.deleteNamespacedDaemonSet = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Extensions_v1beta1Api.prototype.deleteNamespacedDeployment = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete an Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Extensions_v1beta1Api.prototype.deleteNamespacedIngress = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedIngress.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedIngress.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Extensions_v1beta1Api.prototype.deleteNamespacedNetworkPolicy = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Extensions_v1beta1Api.prototype.deleteNamespacedReplicaSet = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Extensions_v1beta1Api.prototype.deletePodSecurityPolicy = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deletePodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deletePodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ThirdPartyResource
     * @param name name of the ThirdPartyResource
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Extensions_v1beta1Api.prototype.deleteThirdPartyResource = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/thirdpartyresources/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteThirdPartyResource.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteThirdPartyResource.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Extensions_v1beta1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind DaemonSet
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listDaemonSetForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/daemonsets';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Deployment
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listDeploymentForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/deployments';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Ingress
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listIngressForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/ingresses';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listNamespacedDaemonSet = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listNamespacedDeployment = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listNamespacedIngress = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listNamespacedNetworkPolicy = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listNamespacedReplicaSet = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind NetworkPolicy
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listNetworkPolicyForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/networkpolicies';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listPodSecurityPolicy = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ReplicaSet
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listReplicaSetForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/replicasets';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ThirdPartyResource
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Extensions_v1beta1Api.prototype.listThirdPartyResource = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/thirdpartyresources';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedDaemonSet = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedDaemonSetStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedDeployment = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedDeploymentStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedDeploymentsScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedDeploymentsScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedDeploymentsScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedDeploymentsScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedIngress = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedIngress.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedIngress.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedIngressStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedIngressStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedIngressStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedIngressStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedNetworkPolicy = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedReplicaSet = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedReplicaSetStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedReplicasetsScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicasetsScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicasetsScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicasetsScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchNamespacedReplicationcontrollersScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedReplicationcontrollersScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedReplicationcontrollersScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedReplicationcontrollersScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchPodSecurityPolicy = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchPodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ThirdPartyResource
     * @param name name of the ThirdPartyResource
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.patchThirdPartyResource = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/thirdpartyresources/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchThirdPartyResource.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchThirdPartyResource.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Extensions_v1beta1Api.prototype.readNamespacedDaemonSet = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.readNamespacedDaemonSetStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Extensions_v1beta1Api.prototype.readNamespacedDeployment = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.readNamespacedDeploymentStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.readNamespacedDeploymentsScale = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedDeploymentsScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedDeploymentsScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Extensions_v1beta1Api.prototype.readNamespacedIngress = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedIngress.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.readNamespacedIngressStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedIngressStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedIngressStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Extensions_v1beta1Api.prototype.readNamespacedNetworkPolicy = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Extensions_v1beta1Api.prototype.readNamespacedReplicaSet = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.readNamespacedReplicaSetStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.readNamespacedReplicasetsScale = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicasetsScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicasetsScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.readNamespacedReplicationcontrollersScale = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedReplicationcontrollersScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedReplicationcontrollersScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Extensions_v1beta1Api.prototype.readPodSecurityPolicy = function (name, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readPodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ThirdPartyResource
     * @param name name of the ThirdPartyResource
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Extensions_v1beta1Api.prototype.readThirdPartyResource = function (name, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/thirdpartyresources/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readThirdPartyResource.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedDaemonSet = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDaemonSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified DaemonSet
     * @param name name of the DaemonSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedDaemonSetStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDaemonSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedDeployment = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeployment.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeployment.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified Deployment
     * @param name name of the Deployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedDeploymentStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedDeploymentsScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedDeploymentsScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedDeploymentsScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedDeploymentsScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedIngress = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedIngress.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedIngress.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedIngress.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified Ingress
     * @param name name of the Ingress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedIngressStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedIngressStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedIngressStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedIngressStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified NetworkPolicy
     * @param name name of the NetworkPolicy
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedNetworkPolicy = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedNetworkPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedReplicaSet = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSet.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified ReplicaSet
     * @param name name of the ReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedReplicaSetStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicaSetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedReplicasetsScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicasetsScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicasetsScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicasetsScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace scale of the specified Scale
     * @param name name of the Scale
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceNamespacedReplicationcontrollersScale = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedReplicationcontrollersScale.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedReplicationcontrollersScale.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedReplicationcontrollersScale.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified PodSecurityPolicy
     * @param name name of the PodSecurityPolicy
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replacePodSecurityPolicy = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/podsecuritypolicies/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replacePodSecurityPolicy.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replacePodSecurityPolicy.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ThirdPartyResource
     * @param name name of the ThirdPartyResource
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Extensions_v1beta1Api.prototype.replaceThirdPartyResource = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/extensions/v1beta1/thirdpartyresources/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceThirdPartyResource.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceThirdPartyResource.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Extensions_v1beta1Api;
}());
exports.Extensions_v1beta1Api = Extensions_v1beta1Api;
var LogsApiApiKeys;
(function (LogsApiApiKeys) {
    LogsApiApiKeys[LogsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(LogsApiApiKeys = exports.LogsApiApiKeys || (exports.LogsApiApiKeys = {}));
var LogsApi = (function () {
    function LogsApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(LogsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    LogsApi.prototype.setApiKey = function (key, value) {
        this.authentications[LogsApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     *
     * @param logpath path to the log
     */
    LogsApi.prototype.logFileHandler = function (logpath) {
        var localVarPath = this.basePath + '/logs/{logpath}'
            .replace('{' + 'logpath' + '}', String(logpath));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'logpath' is not null or undefined
        if (logpath === null || logpath === undefined) {
            throw new Error('Required parameter logpath was null or undefined when calling logFileHandler.');
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     *
     */
    LogsApi.prototype.logFileListHandler = function () {
        var localVarPath = this.basePath + '/logs/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return LogsApi;
}());
exports.LogsApi = LogsApi;
var PolicyApiApiKeys;
(function (PolicyApiApiKeys) {
    PolicyApiApiKeys[PolicyApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(PolicyApiApiKeys = exports.PolicyApiApiKeys || (exports.PolicyApiApiKeys = {}));
var PolicyApi = (function () {
    function PolicyApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(PolicyApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    PolicyApi.prototype.setApiKey = function (key, value) {
        this.authentications[PolicyApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    PolicyApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/policy/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return PolicyApi;
}());
exports.PolicyApi = PolicyApi;
var Policy_v1beta1ApiApiKeys;
(function (Policy_v1beta1ApiApiKeys) {
    Policy_v1beta1ApiApiKeys[Policy_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Policy_v1beta1ApiApiKeys = exports.Policy_v1beta1ApiApiKeys || (exports.Policy_v1beta1ApiApiKeys = {}));
var Policy_v1beta1Api = (function () {
    function Policy_v1beta1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Policy_v1beta1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Policy_v1beta1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Policy_v1beta1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Policy_v1beta1Api.prototype.createNamespacedPodDisruptionBudget = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Policy_v1beta1Api.prototype.deleteCollectionNamespacedPodDisruptionBudget = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Policy_v1beta1Api.prototype.deleteNamespacedPodDisruptionBudget = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Policy_v1beta1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Policy_v1beta1Api.prototype.listNamespacedPodDisruptionBudget = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PodDisruptionBudget
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Policy_v1beta1Api.prototype.listPodDisruptionBudgetForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/poddisruptionbudgets';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Policy_v1beta1Api.prototype.patchNamespacedPodDisruptionBudget = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update status of the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Policy_v1beta1Api.prototype.patchNamespacedPodDisruptionBudgetStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodDisruptionBudgetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Policy_v1beta1Api.prototype.readNamespacedPodDisruptionBudget = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read status of the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Policy_v1beta1Api.prototype.readNamespacedPodDisruptionBudgetStatus = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodDisruptionBudgetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Policy_v1beta1Api.prototype.replaceNamespacedPodDisruptionBudget = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodDisruptionBudget.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodDisruptionBudget.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace status of the specified PodDisruptionBudget
     * @param name name of the PodDisruptionBudget
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Policy_v1beta1Api.prototype.replaceNamespacedPodDisruptionBudgetStatus = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodDisruptionBudgetStatus.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodDisruptionBudgetStatus.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Policy_v1beta1Api;
}());
exports.Policy_v1beta1Api = Policy_v1beta1Api;
var RbacAuthorizationApiApiKeys;
(function (RbacAuthorizationApiApiKeys) {
    RbacAuthorizationApiApiKeys[RbacAuthorizationApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(RbacAuthorizationApiApiKeys = exports.RbacAuthorizationApiApiKeys || (exports.RbacAuthorizationApiApiKeys = {}));
var RbacAuthorizationApi = (function () {
    function RbacAuthorizationApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(RbacAuthorizationApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    RbacAuthorizationApi.prototype.setApiKey = function (key, value) {
        this.authentications[RbacAuthorizationApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    RbacAuthorizationApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return RbacAuthorizationApi;
}());
exports.RbacAuthorizationApi = RbacAuthorizationApi;
var RbacAuthorization_v1alpha1ApiApiKeys;
(function (RbacAuthorization_v1alpha1ApiApiKeys) {
    RbacAuthorization_v1alpha1ApiApiKeys[RbacAuthorization_v1alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(RbacAuthorization_v1alpha1ApiApiKeys = exports.RbacAuthorization_v1alpha1ApiApiKeys || (exports.RbacAuthorization_v1alpha1ApiApiKeys = {}));
var RbacAuthorization_v1alpha1Api = (function () {
    function RbacAuthorization_v1alpha1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(RbacAuthorization_v1alpha1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    RbacAuthorization_v1alpha1Api.prototype.setApiKey = function (key, value) {
        this.authentications[RbacAuthorization_v1alpha1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.createClusterRole = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.createClusterRoleBinding = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.createNamespacedRole = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.createNamespacedRoleBinding = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    RbacAuthorization_v1alpha1Api.prototype.deleteClusterRole = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    RbacAuthorization_v1alpha1Api.prototype.deleteClusterRoleBinding = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.deleteCollectionClusterRole = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.deleteCollectionClusterRoleBinding = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.deleteCollectionNamespacedRole = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.deleteCollectionNamespacedRoleBinding = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    RbacAuthorization_v1alpha1Api.prototype.deleteNamespacedRole = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    RbacAuthorization_v1alpha1Api.prototype.deleteNamespacedRoleBinding = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    RbacAuthorization_v1alpha1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.listClusterRole = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.listClusterRoleBinding = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.listNamespacedRole = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.listNamespacedRoleBinding = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind RoleBinding
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.listRoleBindingForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Role
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1alpha1Api.prototype.listRoleForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/roles';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.patchClusterRole = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.patchClusterRoleBinding = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.patchNamespacedRole = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.patchNamespacedRoleBinding = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ClusterRole
     * @param name name of the ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.readClusterRole = function (name, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.readClusterRoleBinding = function (name, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.readNamespacedRole = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.readNamespacedRoleBinding = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.replaceClusterRole = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.replaceClusterRoleBinding = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.replaceNamespacedRole = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1alpha1Api.prototype.replaceNamespacedRoleBinding = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return RbacAuthorization_v1alpha1Api;
}());
exports.RbacAuthorization_v1alpha1Api = RbacAuthorization_v1alpha1Api;
var RbacAuthorization_v1beta1ApiApiKeys;
(function (RbacAuthorization_v1beta1ApiApiKeys) {
    RbacAuthorization_v1beta1ApiApiKeys[RbacAuthorization_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(RbacAuthorization_v1beta1ApiApiKeys = exports.RbacAuthorization_v1beta1ApiApiKeys || (exports.RbacAuthorization_v1beta1ApiApiKeys = {}));
var RbacAuthorization_v1beta1Api = (function () {
    function RbacAuthorization_v1beta1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(RbacAuthorization_v1beta1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    RbacAuthorization_v1beta1Api.prototype.setApiKey = function (key, value) {
        this.authentications[RbacAuthorization_v1beta1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.createClusterRole = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.createClusterRoleBinding = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.createNamespacedRole = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * create a RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.createNamespacedRoleBinding = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    RbacAuthorization_v1beta1Api.prototype.deleteClusterRole = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    RbacAuthorization_v1beta1Api.prototype.deleteClusterRoleBinding = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.deleteCollectionClusterRole = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.deleteCollectionClusterRoleBinding = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.deleteCollectionNamespacedRole = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.deleteCollectionNamespacedRoleBinding = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    RbacAuthorization_v1beta1Api.prototype.deleteNamespacedRole = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    RbacAuthorization_v1beta1Api.prototype.deleteNamespacedRoleBinding = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    RbacAuthorization_v1beta1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.listClusterRole = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.listClusterRoleBinding = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.listNamespacedRole = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.listNamespacedRoleBinding = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind RoleBinding
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.listRoleBindingForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/rolebindings';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind Role
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    RbacAuthorization_v1beta1Api.prototype.listRoleForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/roles';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.patchClusterRole = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.patchClusterRoleBinding = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.patchNamespacedRole = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.patchNamespacedRoleBinding = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ClusterRole
     * @param name name of the ClusterRole
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.readClusterRole = function (name, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.readClusterRoleBinding = function (name, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.readNamespacedRole = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.readNamespacedRoleBinding = function (name, namespace, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ClusterRole
     * @param name name of the ClusterRole
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.replaceClusterRole = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified ClusterRoleBinding
     * @param name name of the ClusterRoleBinding
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.replaceClusterRoleBinding = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceClusterRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceClusterRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified Role
     * @param name name of the Role
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.replaceNamespacedRole = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRole.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRole.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified RoleBinding
     * @param name name of the RoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    RbacAuthorization_v1beta1Api.prototype.replaceNamespacedRoleBinding = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedRoleBinding.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return RbacAuthorization_v1beta1Api;
}());
exports.RbacAuthorization_v1beta1Api = RbacAuthorization_v1beta1Api;
var SettingsApiApiKeys;
(function (SettingsApiApiKeys) {
    SettingsApiApiKeys[SettingsApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(SettingsApiApiKeys = exports.SettingsApiApiKeys || (exports.SettingsApiApiKeys = {}));
var SettingsApi = (function () {
    function SettingsApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(SettingsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    SettingsApi.prototype.setApiKey = function (key, value) {
        this.authentications[SettingsApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    SettingsApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return SettingsApi;
}());
exports.SettingsApi = SettingsApi;
var Settings_v1alpha1ApiApiKeys;
(function (Settings_v1alpha1ApiApiKeys) {
    Settings_v1alpha1ApiApiKeys[Settings_v1alpha1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Settings_v1alpha1ApiApiKeys = exports.Settings_v1alpha1ApiApiKeys || (exports.Settings_v1alpha1ApiApiKeys = {}));
var Settings_v1alpha1Api = (function () {
    function Settings_v1alpha1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Settings_v1alpha1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Settings_v1alpha1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Settings_v1alpha1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Settings_v1alpha1Api.prototype.createNamespacedPodPreset = function (namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling createNamespacedPodPreset.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Settings_v1alpha1Api.prototype.deleteCollectionNamespacedPodPreset = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteCollectionNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a PodPreset
     * @param name name of the PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Settings_v1alpha1Api.prototype.deleteNamespacedPodPreset = function (name, namespace, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteNamespacedPodPreset.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling deleteNamespacedPodPreset.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Settings_v1alpha1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Settings_v1alpha1Api.prototype.listNamespacedPodPreset = function (namespace, pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets'
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling listNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind PodPreset
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Settings_v1alpha1Api.prototype.listPodPresetForAllNamespaces = function (fieldSelector, labelSelector, pretty, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/podpresets';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified PodPreset
     * @param name name of the PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Settings_v1alpha1Api.prototype.patchNamespacedPodPreset = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchNamespacedPodPreset.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling patchNamespacedPodPreset.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified PodPreset
     * @param name name of the PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Settings_v1alpha1Api.prototype.readNamespacedPodPreset = function (name, namespace, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readNamespacedPodPreset.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling readNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified PodPreset
     * @param name name of the PodPreset
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Settings_v1alpha1Api.prototype.replaceNamespacedPodPreset = function (name, namespace, body, pretty) {
        var localVarPath = this.basePath + '/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'namespace' + '}', String(namespace));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceNamespacedPodPreset.');
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling replaceNamespacedPodPreset.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceNamespacedPodPreset.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Settings_v1alpha1Api;
}());
exports.Settings_v1alpha1Api = Settings_v1alpha1Api;
var StorageApiApiKeys;
(function (StorageApiApiKeys) {
    StorageApiApiKeys[StorageApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(StorageApiApiKeys = exports.StorageApiApiKeys || (exports.StorageApiApiKeys = {}));
var StorageApi = (function () {
    function StorageApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(StorageApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    StorageApi.prototype.setApiKey = function (key, value) {
        this.authentications[StorageApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get information of a group
     */
    StorageApi.prototype.getAPIGroup = function () {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return StorageApi;
}());
exports.StorageApi = StorageApi;
var Storage_v1ApiApiKeys;
(function (Storage_v1ApiApiKeys) {
    Storage_v1ApiApiKeys[Storage_v1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Storage_v1ApiApiKeys = exports.Storage_v1ApiApiKeys || (exports.Storage_v1ApiApiKeys = {}));
var Storage_v1Api = (function () {
    function Storage_v1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Storage_v1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Storage_v1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Storage_v1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Storage_v1Api.prototype.createStorageClass = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Storage_v1Api.prototype.deleteCollectionStorageClass = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Storage_v1Api.prototype.deleteStorageClass = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Storage_v1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Storage_v1Api.prototype.listStorageClass = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Storage_v1Api.prototype.patchStorageClass = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified StorageClass
     * @param name name of the StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Storage_v1Api.prototype.readStorageClass = function (name, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Storage_v1Api.prototype.replaceStorageClass = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Storage_v1Api;
}());
exports.Storage_v1Api = Storage_v1Api;
var Storage_v1beta1ApiApiKeys;
(function (Storage_v1beta1ApiApiKeys) {
    Storage_v1beta1ApiApiKeys[Storage_v1beta1ApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(Storage_v1beta1ApiApiKeys = exports.Storage_v1beta1ApiApiKeys || (exports.Storage_v1beta1ApiApiKeys = {}));
var Storage_v1beta1Api = (function () {
    function Storage_v1beta1Api(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(Storage_v1beta1Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Storage_v1beta1Api.prototype.setApiKey = function (key, value) {
        this.authentications[Storage_v1beta1ApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * create a StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Storage_v1beta1Api.prototype.createStorageClass = function (body, pretty) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete collection of StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Storage_v1beta1Api.prototype.deleteCollectionStorageClass = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * delete a StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     */
    Storage_v1beta1Api.prototype.deleteStorageClass = function (name, body, pretty, gracePeriodSeconds, orphanDependents, propagationPolicy) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = gracePeriodSeconds;
        }
        if (orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = orphanDependents;
        }
        if (propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = propagationPolicy;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * get available resources
     */
    Storage_v1beta1Api.prototype.getAPIResources = function () {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * list or watch objects of kind StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    Storage_v1beta1Api.prototype.listStorageClass = function (pretty, fieldSelector, labelSelector, resourceVersion, timeoutSeconds, watch) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = fieldSelector;
        }
        if (labelSelector !== undefined) {
            queryParameters['labelSelector'] = labelSelector;
        }
        if (resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = resourceVersion;
        }
        if (timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = timeoutSeconds;
        }
        if (watch !== undefined) {
            queryParameters['watch'] = watch;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * partially update the specified StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Storage_v1beta1Api.prototype.patchStorageClass = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling patchStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * read the specified StorageClass
     * @param name name of the StorageClass
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
     * @param _export Should this value be exported.  Export strips fields that a user can not specify.
     */
    Storage_v1beta1Api.prototype.readStorageClass = function (name, pretty, exact, _export) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling readStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        if (exact !== undefined) {
            queryParameters['exact'] = exact;
        }
        if (_export !== undefined) {
            queryParameters['export'] = _export;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     *
     * replace the specified StorageClass
     * @param name name of the StorageClass
     * @param body
     * @param pretty If &#39;true&#39;, then the output is pretty printed.
     */
    Storage_v1beta1Api.prototype.replaceStorageClass = function (name, body, pretty) {
        var localVarPath = this.basePath + '/apis/storage.k8s.io/v1beta1/storageclasses/{name}'
            .replace('{' + 'name' + '}', String(name));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling replaceStorageClass.');
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling replaceStorageClass.');
        }
        if (pretty !== undefined) {
            queryParameters['pretty'] = pretty;
        }
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return Storage_v1beta1Api;
}());
exports.Storage_v1beta1Api = Storage_v1beta1Api;
var VersionApiApiKeys;
(function (VersionApiApiKeys) {
    VersionApiApiKeys[VersionApiApiKeys["BearerToken"] = 0] = "BearerToken";
})(VersionApiApiKeys = exports.VersionApiApiKeys || (exports.VersionApiApiKeys = {}));
var VersionApi = (function () {
    function VersionApi(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BearerToken': new ApiKeyAuth('header', 'authorization')
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(VersionApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    VersionApi.prototype.setApiKey = function (key, value) {
        this.authentications[VersionApiApiKeys[key]].apiKey = value;
    };
    /**
     *
     * get the code version
     */
    VersionApi.prototype.getCode = function () {
        var localVarPath = this.basePath + '/version/';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };
        this.authentications.BearerToken.applyToRequest(requestOptions);
        this.authentications["default"].applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return VersionApi;
}());
exports.VersionApi = VersionApi;
